# The DOM
## The Document Object Model (DOM)
```javascript
// The Document Object Model, or DOM, is an in-memory object representation of an HTML document. It provides a way to interact with a web page using JavaScript and provides the functionality needed to build modern interactive user experiences.

```
```javascript A Hierarchy of Nodes
<html>
  <h1>Hello, world!</h1>
  <p>This is a small <em>web page</em>.</p>
</html>

// a fundamental tenet of the web is permissiveness; they always do their best to display HTML even when it has errors.

Elements represent HTML tags
Text nodes represent text that appears in the document.

empty nodes = text nodes of just white space
// Empty nodes can appear pretty much anywhere.


```
Node Properties
```javascript Determining the Type of a Node
> document.toString()
//"[object HTMLDocument]"

> document.toString()
// "[object HTMLDocument]"

The nodeName property contains a String that represents the node type. For Elements (anything that represents an HTML tag), this is the name of the corresponding tag in uppercase.
> p.nodeName
// = "P"
// For text nodes -- even empty nodes -- the nodeName is "#text". For comments, it's "#comment".

nodeType
You can use the nodeType property to determine a node's type: it returns a number that matches a node type constant.

Copy Code
> p.nodeType
// = 1
COMPLETE LIST = https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType
Constant	Value	Description
Node.ELEMENT_NODE	1	An Element representing an HTML tag
Node.TEXT_NODE	3	A Text node
Node.COMMENT_NODE	8	A Comment node
Node.DOCUMENT_NODE	9	A Document node

> p.nodeType === Node.ELEMENT_NODE
// = true
> document.nodeType === Node.DOCUMENT_NODE
// = true

nodeValue
The nodeValue property references the value of a node. Element nodes don't have values:'
> p.nodeValue
// = null
Text nodes do, though. For a text node, the nodeValue is the textual content of the node

> let t = p.childNodes[0];

> t.nodeName;
= "#text"// the return value of toString, we learn that t is a text node
> t.toString();
= "[object Text]"//its type is Text
> t.nodeValue
// = "To receive our weekly emails, enter your email address below. "


textContent represents //the textual content of all the nodes inside the Element. You can think of it as the nodeValue for all the Element's child nodes concatenated into a single String.

> document.querySelector("p").textContent
= "
      To receive our weekly emails, enter your email address below.
      Get more info.
    "
    // Notice all the whitespace in the String. textContent joins the nodeValues of all child Text Nodes together, including the empty Nodes, which leads to excess whitespace. You can deal with the excess whitespace using the usual String and RegExp methods.'

https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace_in_the_DOM

All DOM objects are Nodes.
All DOM objects have a type that inherits from Node, which means they all have properties and methods they inherit from Node.
The most common DOM object types you will use are Element and Text.

Elements include more specific, specialized Element types. For example, the DOM node that represents a <p> HTML tag has type HTMLParagraphElement, while the Element that represents a <div> tag is HTMLDivElement

Why does a Node's type matter?

A node's type determines what properties and methods it provides to a developer. Determining the element type is important so that you know what you can do with the node. It's easy to determine whether something is a Text node or an Element, but it's tricky to determine the exact Element type. Once you do know it, though, you can find the documentation on MDN.
https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement



```
```javascript Inheritance and Finding Documentation
EventTarget provides the event-handling behavior that supports interactive web applications. We'll study this in detail in an upcoming lesson.
Node provides common behavior to all nodes.
Text and Element are the chief subtypes of Node.
Text nodes hold text.
Element nodes represent HTML tags.
Most HTML tags map to specific element subtypes that inherit from HTMLElement.
Other element types exist, such as SVGElement and its subtypes

two useful ways to determine a node type: one works best in interactive console sessions using the browser's developer tools, while the other works best from a program.
most useful on the console uses the toString method or the String constructor on the node; you can read the name from the display:

> p.toString();
// = "[object HTMLParagraphElement]"
> let a = document.querySelector('a');
> a
= <a href="http://domain.com/page">Page</a>
> a.toString();
// = "http://domain.com/page" //Not all nodes work with toString

As a workaround, you can call the node's constructor property; it references a function that creates Objects of the appropriate Element type. The value is browser-dependent, though, which adds some clumsiness when using it.

ChromeCopy Code
> document.querySelector('a').constructor;
// = function HTMLAnchorElement() { [native code] }

If you're writing a program, you should probably use the instanceof operator or tagName property.

With element nodes, tagName returns the same value as nodeName.

instanceof checks whether an object has a type that matches or inherits from a named type.

Copy Code
> let p = document.querySelector('p');
> p instanceof HTMLParagraphElement;
// = true
> p instanceof HTMLAnchorElement;
// = false
> p instanceof Element;
// = true

> p instanceof HTMLElement;
// = true
> p instanceof Element;
// = true
> p instanceof Node;
// = true
> p instanceof SVGElement;
// = false

> p.tagName;
// = "P"


```
```javascript Traversing Nodes
Parent Node Properties	Value
firstChild	childNodes[0] or null
lastChild	childNodes[childNodes.length - 1] or null
childNodes	Live collection of all child nodes

Child Node Properties	Value
nextSibling	parentNode.childNodes[n + 1] or null
previousSibling	parentNode.childNodes[n - 1] or null
parentNode	Immediate parent of this node

function iterateAndLog(array) {
  for (let index = 0; index < array.length; index += 1) {
    console.log(array[index]);
  }
}

RECURSIVE VERSION
function recurseAndLog(array) {
  if (array.length > 0) {
    console.log(array[0]);
    recurseAndLog(array.slice(1));
  }
}

NODE WALKING RECURSION
function walk(node) {
  console.log(node.nodeName);                                       // do something with node
  for (let index = 0; index < node.childNodes.length; index += 1) { // for each child node
    walk(node.childNodes[index]);                                   // recursively call walk()
  }
}

walk(document.body);                                                // log nodeName of every node

// walk() calls the function "callback" once for each node
function walk(node, callback) {
  callback(node);                                                   // do something with node
  for (let index = 0; index < node.childNodes.length; index += 1) { // for each child node
    walk(node.childNodes[index], callback);                         // recursively call walk()
  }
}

walk(document.body, node => {                                // log nodeName of every node
  console.log(node.nodeName);
});


```
```javascript Element Attributes
Getting and Setting Attributes
Method	Description	Returns
getAttribute(name)	Retrieve value of attribute name	Value of attribute as string
setAttribute(name, newValue)	Set value of attribute name to newValue	undefined
hasAttribute(name)	Check whether element has attribute name	true or false

> p.hasAttribute('class');
= true
> p.getAttribute('class');
= "intro"
> p.getAttribute('id');
= "simple"
> p.setAttribute('id', 'complex');
> p
= <p class="intro" id="complex">...</p>

Attribute Properties
The DOM exposes these special attributes as properties of the Element: id, name, title, and value. You can fetch the value for one of these properties or set it to a new value using standard property access and assignment operations:

> p;
= <p class="intro" id="simple">...</p>
> p.id
= "simple"
> p.id = 'complex'
> p;
= <p class="intro" id="complex">...</p>

classList
More than one class in some HTML //<button class="btn btn-lg btn-primary">Proceed</button>

> button.className;
= "btn btn-lg btn-primary"

> let newClass = button.className.replace('btn-primary', 'btn-disabled');
> button.className = newClass;
= "btn btn-lg btn-disabled"
> button;
= <button class="btn btn-lg btn-disabled">...</button>

Name	Description
add(name)	Add class name to element
remove(name)	Remove class name from element
toggle(name)	Add class name to element if it doesn't exist, remove if it does exist
contains(name)	Return true or false depending on whether element has class name
length	The number of classes to which element belongs

style
> let h1 = document.querySelector('h1');
> h1.style;
= CSSStyleDeclaration {alignContent: "", alignItems: "", alignSelf: "", alignmentBaseline: "", all: "", ...}

> h1.style.color = 'red';//change the color
> h1.style.color = null;//remove property

> h1.style.lineHeight = '3em';//When a CSS property's name contains dashes, you must use a camelCased version of the name to access that property

```
Practice Problems: Traversing and Accessing Attributes
```javascript Finding DOM Nodes
Method	Returns
document.getElementById(id)	element with given id

<!doctype html>
<html lang="en-US">
  <head>
    <title>On the River</title>
  </head>
  <body>
    <p id="content">The sun is low</p>
  </body>
</html>

> document.getElementById('content');
= <p id="content">...</p>

// In fact, it's often easier to maintain your application if you structure the code to find all matching elements instead of just one.

function findAllParagraphs() {
  let matches = [];
  let nodes = document.body.childNodes;

  for (let index = 0; index < nodes.length; index += 1) {
    if (nodes[index] instanceof HTMLParagraphElement) {
      matches.push(nodes[index]);
    }
  }

  return matches;
}

console.log(findAllParagraphs());

Method	Returns
document.getElementsByTagName(tagName)	HTMLCollection or NodeList of matching elements
document.getElementsByClassName(className)	HTMLCollection or NodeList of matching elements

What is a HTMLCollection or NodeList?

// Both types are array-like objects, which means they are containers for other objects indexed by non-negative integers.

// Since these are not JavaScript arrays, they do not support forEach or other array methods. (NodeList on some browsers do support forEach, but not on all browsers; HTMLCollection provides no support for forEach.) To loop through the elements returned by these methods, use a for loop or convert the object into an array and then use the higher-order array functions.


let paragraphs = document.getElementsByTagName("p");

paragraphs.length; // returns a Number
paragraphs[0]; // returns first element in collection

// The following will fail with "forEach" not available in some browsers
paragraphs.forEach((paragraph) => console.log(paragraph.textContent));

// Possible fix
let paragraphsArray = Array.prototype.slice.call(paragraphs);
paragraphsArray.forEach((paragraph) => console.log(paragraph.textContent));

// Alternative fix
for (let index = 0; index < paragraphs.length; index += 1) {
  let paragraph = paragraphs[index];
  console.log(paragraph.textContent);
}

Live Collection
Some DOM-querying methods return collections that are called live collections. Live collections have a special behavior in that they automatically update to reflect changes in the DOM, hence the term "live". Methods like document.getElementsByClassName and document.getElementsByTagName, when they return an HTMLCollection, return it in the form of a live collection. It is important to take note of this because it can lead to unexpected behavior, especially when you iterate over it or use the return value.

Here's code demonstrating a live collection:

HTMLCopy Code
<ul id="list">
  <li class="list-item">Item 1</li>
  <li class="list-item">Item 2</li>
  <li class="list-item">Item 3</li>
</ul>
Using the above markup, we're now going to add a new element with the class of "list-item." Observe what happens when we log the .length property of the value assigned to listItems:

JavaScriptCopy Code
let list = document.querySelector("#list");
let listItems = document.getElementsByClassName("list-item");
console.log(listItems.length); // logs 3

// We'll cover creating elements in a later assignment
let newItem = document.createElement("li"); // Creates a new element
newItem.className = "list-item"; // adds a class to the element
list.appendChild(newItem); // appends to "list" element

console.log(listItems.length); // logs 4
Notice how the listItems' length increases even though we didn't explicitly add any elements to it.

let paragraphs = document.getElementsByTagName("p");
for (let index = 0; index < paragraphs.length; index += 1) {
  paragraphs[index].classList.add("article-text");
}

let intros = document.getElementsByClassName("intro");
for (let index = 0; index < intros.length; index += 1) {
  let paragraphs = intros[index].getElementsByTagName("p");

  for (let p = 0; p < paragraphs.length; p += 1) {
    paragraphs[p].classList.add("article-text");
  }
}

let intros = document.getElementsByClassName("intro");
for (let index = 0; index < intros.length; index += 1) {
  intros[index].firstElementChild.classList.add("article-text");
}

'It's safer to search for specific code than to rely on relative positions of elements.'

Using CSS Selectors

document.querySelector(selectors)	First matching element or null
document.querySelectorAll(selectors)	NodeList of matching elements

<div id="divOne"></div>
<div id="divTwo"></div>
> document.querySelector('#divTwo, #divOne');
= <div id="divOne"></div>    // returns the first matching element;
                             // div with an id of `divOne` matched first
> document.querySelectorAll('#divTwo, #divOne');
= NodeList(2) [div#divOne, div#divTwo]

// previous approach
let intros = document.getElementsByClassName("intro");
for (let index = 0; index < intros.length; index += 1) {
  let paragraphs = intros[index].getElementsByTagName("p");

  for (let p = 0; p < paragraphs.length; p += 1) {
    paragraphs[p].classList.add("article-text");
  }
}

// using querySelectorAll
let paragraphs = document.querySelectorAll(".intro p");
for (let index = 0; index < paragraphs.length; index += 1) {
  paragraphs[index].classList.add("article-text");
}

```
```javascript Traversing Elements
children	Live collection of all child elements
firstElementChild	children[0] or null
lastElementChild	children[children.length - 1] or null
childElementCount	children.length

nextElementSibling	parentNode.children[n + 1] or null
previousElementSibling	parentNode.children[n - 1] or null

Most browsers include these properties in document, which has type Document. Internet Explorer does not, though; it provides them in document.body instead. You can use document.body with them all and get the expected results.

<!doctype html>
<html lang="en-US">
  <head>
    <title>Go Back or Continue</title>
  </head>

  <body>
    <p>
      You can <a href="?page=2">go back</a> or <a href="/page/3">continue</a>.
    </p>
  </body>
</html>
> document.querySelector('a').textContent;
// = "go back"

> document.querySelector('a').textContent = 'step backward';
// = "step backward"

Be careful when setting textContent; doing so removes all child nodes from the element and replaces them with a text node that contains the value:

Copy Code
> document.querySelector('p').textContent = "You can't go anywhere.";
= "You can't go anywhere."
<!doctype html>
<html lang="en-US">
  <head>
    <title>Go Back or Continue</title>
  </head>
  <body>
    <p>You can't go anywhere.</p>//Notice how other links dissappeared
  </body>
</html>

// The best strategy for updating text with JavaScript is to place the text you need to update within an element; the element type doesn't matter -- even a bare span or div element will suffice. This approach makes using textContent simpler and safer to use.

<!doctype html>
<html lang="en-US">
  <head>
    <title>My Site</title>
  </head>
  <body>
    <div>
      Welcome to the site!<br>
      The time is 9:15 am.<br>
      You are logged in as <a href="/account">Kabu</a>.
    </div>
  </body>
</html>

var div = document.querySelector('div');
var node;
var newText;

for (let index = 0; index < div.childNodes.length; index += 1) {
  node = div.childNodes[index];
  if (node instanceof Text && node.nodeValue.indexOf('The time is') !== -1) {
    newText = node.nodeValue.replace(/\d{1,2}:\d{2} [ap]m/, '9:16 am');
    node.nodeValue = newText;
  }
}

<!doctype html>
<html lang="en-US">
  <head>
    <title>My Site</title>
  </head>
  <body>
    <div>
      Welcome to the site!<br>
      The time is <span class="time">9:15 am</span>.<br>
      You are logged in as <a href="/account">Kabu</a>.
    </div>
  </body>
</html>

document.querySelector('.time').textContent = '9:16 am';
```
```javascript Practice Problems: Finding Nodes and Traversing Elements
let paragraph = document.createElement('p');
paragraph.textContent = 'This is a test.';
document.body.appendChild(paragraph);

let text = document.createTextNode('This is a test.');
let paragraph = document.createElement('p');
paragraph.appendChild(text);
document.body.appendChild(paragraph);


```
```javascript Creating and Moving DOM Nodes
Creating New Nodes
You can create nodes in two ways: you can create new empty nodes with the document.create* methods, or you can clone an existing node hierarchy:

Node Creation Method	Returns
document.createElement(tagName)	A new Element node
document.createTextNode(text)	A new Text node
node.cloneNode(deepClone)	Returns a copy of node

If deepClone is true, cloneNode makes copies of node and all its children; otherwise, cloneNode merely copies node. Don't rely on a specific default value for deepClone; it has changed over time, so always specify true or false to get what you want. In most cases, you'll use true to get a copy of the node and its children.

You can append, insert, and replace nodes with methods on the node's parent:

Parent Node Method	Description
parent.appendChild(node)	Append node to the end of parent.childNodes
parent.insertBefore(node, targetNode)	Insert node into parent.childNodes before targetNode
parent.replaceChild(node, targetNode)	Remove targetNode from parent.childNodes and insert node in its place
document.appendChild causes an error. Use document.body.appendChild instead.

These methods insert node before, after, or within an Element:

Element Insertion Method	Description
element.insertAdjacentElement(position, newElement)	Inserts newElement at position relative to element
element.insertAdjacentText(position, text)	Inserts Text node that contains text at position relative to element

Position	Description
"beforebegin"	Before the element
"afterbegin"	Before the first child of the element
"beforeend"	After the last child of the element
"afterend"	After the element

Removing Nodes
When you remove a node from the DOM, it becomes eligible for garbage collection unless you keep a reference to the node in a variable. You cannot access an object that is eligible for garbage collection, so it's no longer available to your program.

Element Method	Description
node.remove()	Remove node from the DOM
parent.removeChild(node)	Remove node from parent.childNodes

document.body.setAttribute('id', 'styled');
```
```javascriptThe Browser Object Model (BOM)

```
```javascript Practice Problems: The DOM

// Parent element and children element tag printing
function domTreeTracer(id) {
  let currentElement = document.getElementById(id);
  let parentElement;
  const domTree = [];

  do {
    parentElement = currentElement.parentNode;
    let children = getTagNames(parentElement.children);
    domTree.push(children);

    currentElement = parentElement;
  } while (parentElement.tagName !== 'BODY');

  return domTree;
}

function getTagNames(htmlCollection) {
  const elementsArray = Array.from(htmlCollection);
  return elementsArray.map(({tagName}) => tagName);
}


```
Assignment: DOM Shuffling

# Event-Driven and Asynchronous Programming
```javascript Asynchronous Execution with setTimeout
// You can't determine whether code is asynchronous solely by looking at it. If it calls any functions, then you must be familiar with the behavior of each of those functions to determine whether any are asynchronous. You must also know whether the code you're looking at was invoked asynchronously.

function makeLogger(number) {
  return function() {
    console.log(number);
  }
}

function delayLog() {
  for (let index = 1; index <= 10; index += 1) {
    let logger = makeLogger(index);
    setTimeout(logger, index * 1000);
  }
}


```
```javascript Repeating Execution with setInterval
function save() {
  // Send the form values to the server for safe keeping
}

// Call save() every 10 seconds
let id = setInterval(save, 10000);

// Later, perhaps after the user submits the form
clearInterval(id);

```
```javascript User Interfaces and Events
// An event is an object that represents some occurrence; it contains information about what happened and where it happened. The browser can trigger events as the page loads, when the user interacts with the page, and when the browser performs some action required by the program.

// User interfaces are inherently event-driven. An interface draws itself on the screen, and then it does nothing until a user interacts with it. That interaction could be a button-click, a finger-swipe, or even a shake of a motion-sensitive device. Such interfaces require the program to register some behavior that the event will trigger when it occurs.

Since a lot of web applications consist mainly of a user interface, the code within them has two main tasks:

1. Set up the user interface and display it.
2. Handle events resulting from user or browser actions.

// Since we're working in the browser, we typically achieve #1 with HTML, which lets us focus on #2, handling events.

<!doctype html>
<html lang="en-US">
  <head>
    <title>title</title>
    <meta charset="UTF-8">
    <script>
      document.addEventListener('DOMContentLoaded', event => {
        let addButton = document.getElementById('add');
        let output = document.getElementById('output');
        let count = 0;

        addButton.addEventListener('click', event => {
          count += 1;
          output.textContent = String(count);
        });
      });
    </script>
  </head>

  <body>
    <p>
      <span id="output">0</span>
      <button id="add">Add One</button>
    </p>
  </body>
</html>
```
A Simple Example
```javascript Page Lifecycle Events
// DOM Content Loaded is important because JS runs before the HTML is displayed, so it needs to wait to load properly.

```
```javascript User Events
Event Type	Example Events
Keyboard	keydown, keyup, keypress
Mouse	mouseenter, mouseleave, mousedown, mouseup, click
Touch	touchdown, touchup, touchmove
Window	scroll, resize
// Form	submit
COMPLETE LIST OF EVENTS
https://developer.mozilla.org/en-US/docs/Web/Events


```
```javascript Adding Event Listeners
The rest of this lesson primarily focuses on JavaScript code that uses event listeners, also known as event handlers. Event listeners are functions that the JavaScript runtime calls when a particular event occurs. There are four steps needed to setup an event handler:

Identify the event you need to handle. User actions, the page lifecycle, and more can fire events.
// Identify the element that will receive the event. Depending on the event, the object could be a button, an input field, or any other element on the page.
Define a function to call when this event occurs. The function is passed a single argument, an Event object. For now, we won't be using this argument. We'll learn more about Events later.
// Register the function as an event listener. This step brings the first three together into a working system.

<html>
  <head>
    <title>Test Page</title>
    <script>
      let alertButton = document.getElementById("alert");

      alertButton.addEventListener("click", () => {
        // let button = document.getElementById("alert");
        let message = document.getElementById("message");

        // alertButton.addEventListener("click", () => {
          message.textContent = "ALERT!";
        // })

      })

      document.addEventListener("DOMContentLoaded", () => {
        let button = document.getElementById("alert");
        button.addEventListener("click", displayAlert);
      });

      OR

      document.addEventListener("DOMContentLoaded", () => {
  let button = document.getElementById("alert");
  button.addEventListener("click", (event) => {
    let message = document.getElementById("message").value;
    alert(message);
  });
});
    </script>
  </head>
  <body>
    <textarea id="message"></textarea>
    <button id="alert">Alert</button>
  </body>
</html>

https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers
https://caniuse.com/#search=addEventListener


```
```javascript The Event Object
// Some useful properties that appear in Event objects include:

Property	Description
type	The name of the event (e.g., 'click')
currentTarget	The current object that the event object is on. It always refers to the element that has the event listener attached to it
target	The initial object to receive notification of the event, e.g., the element clicked by the user

Mouse Events
Most events have properties specific to their type. For example, here are some of the properties available for mouse events:

Property	Description
button	This is a read-only property that indicates which button was pressed
clientX	The horizontal position of the mouse when the event occurred
clientY	The vertical position of the mouse when the event occurred
Both clientX and clientY return values relative to the visible area of the page: the number of pixels from the upper-left corner of the browser's viewport.

Keyboard Events
Keyboard-related events also have special properties:

Property	Description
key	The string value of the pressed key. Older browsers do not support this property
shiftKey	Boolean value that indicates whether the user pressed the shift key
altKey	Boolean value that indicates whether the user pressed the alt (or option)
ctrlKey	Boolean value that indicates whether the user pressed the control key
metaKey	Boolean value that indicates whether the user pressed the meta (or command) key

https://developer.mozilla.org/en-US/docs/Web/Events

document.addEventListener('click', event => {
  let x = document.querySelector('.x');
  x.style.left = String(event.clientX) + 'px';
  x.style.top = String(event.clientY) + 'px';
});

document.addEventListener('mousemove', event => {
  let x = document.querySelector('.x');
  x.style.left = String(event.clientX) + 'px';
  x.style.top = String(event.clientY) + 'px';
});

document.addEventListener('keyup', event => {
  let key = event.key;
  let color;

  if (key === 'r') {
    color = 'red';
  } else if (key === 'g') {
    color = 'green';
  } else if (key === 'b') {
    color = 'blue';
  }

  if (color) {
    let x = document.querySelector('.x');
    for (let index = 0; index < x.children.length; index += 1) {
      var child = x.children[index];
      child.style.background = color;
    }
  }
});

document.addEventListener('DOMContentLoaded', () => {
  let composer = document.querySelector('.composer');
  let textarea = composer.querySelector('textarea');
  let counter = composer.querySelector('.counter');
  let button = composer.querySelector('button');

  function updateCounter() {
    let length = textarea.value.length;
    let remaining = 140 - length;
    let message = `${remaining.toString()} characters remaining`;
    let invalid = remaining < 0;

    textarea.classList.toggle('invalid', invalid);
    button.disabled = invalid;

    counter.textContent = message;
  }

  textarea.addEventListener('keyup', updateCounter);

  updateCounter();
});
```
```javascript Capturing and Bubbling

<css>
HTML CSSResult Skip Results Iframe
EDIT ON
#elem1 {
  background-color: green;
  position: relative;
  width: 200px;
  height: 200px;
  text-align: center;
  cursor: pointer;
}

#elem2 {
  background-color: blue;
  position: absolute;
  top: 25px;
  left: 25px;
  width: 150px;
  height: 150px;
}

#elem3 {
  background-color: red;
  position: absolute;
  top: 25px;
  left: 25px;
  width: 100px;
  height: 100px;
  line-height: 25px;
}

#elem4 {
  background-color: yellow;
  position: absolute;
  top: 25px;
  left: 25px;
  width: 50px;
  height: 50px;
  line-height: 50px;
}



Resources1× 0.5× 0.25×Rerun
</css>
<div id="elem1">1
  <div id="elem2">2
    <div id="elem3">3
      <div id="elem4">4
      </div>
    </div>
  </div>
</div>
<script>
let elem4 = document.querySelector('#elem4');

elem4.addEventListener('click', event => alert(event.target.id));
</script>

// even though we added an event listener to a single element, we can interact with three different elements.
// The above, described behavior, surfaces the relationship of nested elements to events.

target vs. currentTarget
alert(event.currentTarget.id);

value of this within the handler when using a function expression
The value of this within the handler when using a function expression is the element that the listener was added to — currentTarget. As such, the following code are equivalent:

Copy Code
// take note that the function expression syntax is used to create the callback function
elem2.addEventListener('click', function(event) {
  alert(event.currentTarget.id);
});

// is equivalent to
elem2.addEventListener('click', function(event) {
  alert(this.id);
});

Scenario 3: Adding the Event Listener to the Innermost and Outermost Element
Capturing and bubbling are phases that an event goes through after it initially fires. The event first gets dispatched to the global window object, then to the document object, all the way down to the target element, which is the element on which the event was originally fired. At this point, this dispatch process reverses and from the target element the event works its way through containing elements until it reaches the window object. Using the HTML from our scenario of "Adding the Event Listener to the Innermost and Outermost Element", this process looks like this:

The diagram may suggest that there are many click events happening, but actually, there's just one click event. This one click event object moves through the capturing and bubbling phases and checks if there are any listeners for it on the DOM objects that it passes.

Note2: The event gets dispatched to each element twice, once during the capturing phase and once during the bubbling phase. The actual event listener, though, gets called/fired in only one phase. By default the listener is set to fire during the "bubbling" phase. To set it to listen on the "capturing phase" you can use the third optional, argument, for the addEventListener method, useCapture, and set it to true.

Copy Code
elem1.addEventListener('click', callbackFunction, true);
// Notice the third argument. It's set to `true`. When it's set to true, the event listener will listen during the capturing phase. If not specified, `useCapture` defaults to `false` and the event listener listens during the bubbling phase.
Note3: When event listeners fire on the target element it is also described as firing on the "target phase."

The diagram may suggest that there are many click events happening, but actually, there's just one click event. This one click event object moves through the capturing and bubbling phases and checks if there are any listeners for it on the DOM objects that it passes.

Note2: The event gets dispatched to each element twice, once during the capturing phase and once during the bubbling phase. The actual event listener, though, gets called/fired in only one phase. By default the listener is set to fire during the "bubbling" phase. To set it to listen on the "capturing phase" you can use the third optional, argument, for the addEventListener method, useCapture, and set it to true.

Copy Code
elem1.addEventListener('click', callbackFunction, true);
// Notice the third argument. It's set to `true`. When it's set to true, the event listener will listen during the capturing phase. If not specified, `useCapture` defaults to `false` and the event listener listens during the bubbling phase.
// Note3: When event listeners fire on the target element it is also described as firing on the "target phase."

Let's take the case of scenario 2 where we were able to interact with the child elements even though an event listener was only attached to their parent. We could interact with the child elements because when we clicked on a child element, the click event bubbled up — from the target — and passed the parent object which had a listener for it.

// Taking the case of scenario 3, the mechanism of capturing and bubbling also explains why there are two alert boxes when we click on the div#elem4 element only once; the event that was triggered by clicking on the div#elem4 element starts from the window object then reaches the target/div#elem4 element — invoking/calling its event handler — and then moves back up to the window object — passing the parent div#elem1 element and firing its event handler. This also shows that the click event listeners, by default, are listening on the bubbling phase because the alert box on the div#elem1 element shows up last.

```
```javascript Preventing Propagation and Default Behaviors
Stopping Propagation
event.stopPropagation stops the event object from continuing its path along the capturing and bubbling phases. Check out the examples below to see it in action.


function turnRed(event) {
  event.currentTarget.style.background = 'red';
}

document.addEventListener('DOMContentLoaded', () => {
  document.querySelector('.outer').addEventListener('click',  turnRed);
  document.querySelector('.inner').addEventListener('click',  turnRed);
});

event.stopPropagation(); // Tells the browser to stop bubbling the event up to parents

document.querySelector('.outer').addEventListener('click',  turnRed, true);
// Coupled with the stopPropagation code on the turnRed callback function, this code stops the event object from continuing on the capturing phase

preventDefault. This method tells the browser that it shouldn't perform any actions that it might otherwise perform in response to a user's action. For instance, clicking a link typically loads a new page in the browser. preventDefault tells the browser not to do that.

hen a user clicks the "View page" link, the browser loads the page identified by the href attribute. CodePen overrides this behavior, and loads the new page in the right pane of the viewer, but, in a regular browser window, the new page will replace the existing page.

document.addEventListener('DOMContentLoaded', () => {
  document.querySelector('a').addEventListener('click', event => {
    event.preventDefault();
    alert('Following the link was prevented.');
  });
});

The default behavior isn't for the element that the event listener is attached to, but rather for the event object; the anchor element's "click" event listener didn't have a preventDefault but a new page wasn't loaded.
The browser waits for the event object to go through the propagation phases (capturing and bubbling) before it performs the default action of the event. If there's an event handler with a preventDefault call somewhere in the propagation path, the default behavior is skipped.

function clickHandler(event) {
  let message = document.getElementById('message');
  message.textContent = `${event.target.textContent} was clicked!`;
}

document.addEventListener('DOMContentLoaded', () => {
  let buttons = document.querySelectorAll('button');

  for (let index = 0; index < buttons.length; index += 1) {
    buttons[index].addEventListener('click', clickHandler);
  }
});// this is wasteful and tedious

Event delegation takes advantage of event propagation to address these problems. Instead of adding listeners to every element you're watching, you can add a single handler to any common ancestor (a parent, grandparent, or something further up the DOM tree) of the elements you want to to watch. The listener, in turn, performs the required actions for each element.

Our simple example lets us attach the single event handler directly to document, which means we don't have to wait until the DOM is ready. Within the handler, we can determine which DOM element triggered the event using event.target:

document.addEventListener('click', event => {
  if (event.target.tagName === 'BUTTON') {
    let message = document.getElementById('message');
    message.textContent = `${event.target.textContent}  was clicked!`;
  }
});

When To Use Event Delegation
The best approach is to start by binding event handlers directly to elements when a project is new and small. As the code grows in size and complexity, delegation may make sense to reduce the number of event handlers required.

Keep in mind that you don't need to use document as the delegator: you can delegate events to any common ancestor element of the elements you want to monitor. You can even have more than one element handling delegated events if it makes sense.

jQuery, which we'll look at in an upcoming lesson, includes functionality that makes delegation comparatively easy while avoiding the complexity drawback.
```
Event Delegation
What is the Event Loop?
```javascript Assignment: Guessing Game
https://launchschool.com/posts/6c011d41

https://launchschool.com/gists/58925b8e


```
Assignment: Build an Input Box
```javascript Douglas Crockford: An Inconvenient API
Summary
setTimeout(callback, delay) invokes a function after the specified number of milliseconds.

setInterval(callback, delay) invokes a function repeatedly in intervals of some specified number of milliseconds. clearInterval clears the interval and prevents future invocations of the Function.

An event is an object that represents some occurrence and contains a variety of information about what happened and where it happened. The browser triggers some events as it loads a page and when it accomplishes some actions directed by an application. The user also triggers events when he interacts with the page.

Code that must access the DOM should be invoked after the DOMContentLoaded event fires on document.

User events drive most user interfaces and can result from a user interacting with the keyboard, mouse, touchscreen, window or other devices. Examples of these user events are click, mouseover, keydown, and scroll.

Event listeners are callbacks that the browser will invoke when a matching event occurs.

element.addEventListener registers an event listener. You can also use specific GlobalEventHandlers like element.onclick, to register an event handler.

The Event object provides the useful properties type, target, and currentTarget.

Keyboard events have properties like key (and others) describes the keys the user pressed. Mouse events similarly provide button, clientX, and clientY.

Events propagate in three phases: capturing, target, and bubbling.

event.preventDefault prevents default browser behavior in response to an event. event.stopPropagation stops the current capturing or bubbling phase, which prevents the event from firing on containing or contained elements.

Event delegation is a technique used to handle events triggered by multiple elements using a single event handler.

https://launchschool.com/exercise_sets/59b16ce9
```

# Making HTTP Requests from JavaScript
```javascript HTTP Review
https://launchschool.com/books/http
https://launchschool.com/lessons/a4bdd0a6/assignments/0f59c8fb

No doubt you've performed searches many times and notice the page doesn't refresh. The Network tab however gives us some new insight into what's happening: every letter you type is issuing a new request, which means that an AJAX request is triggered with every key-press. The responses from these requests are being processed by some callback. You can think of a callback as a piece of logic you pass on to some function to be executed after a certain event has happened. In this case, the callback is triggered when the response is returned. You can probably guess that the callback that's processing these asynchronous requests and responses is updating the HTML with new search results.

We won't get into what the callback looks like or how to issue an AJAX request, but the main thing to remember is that AJAX requests are just like normal requests: they are sent to the server with all the normal components of an HTTP request, and the server handles them like any other request. The only difference is that instead of the browser refreshing and processing the response, the response is processed by a callback function, which is usually some client-side JavaScript code.

TLS - http://en.wikipedia.org/wiki/Transport_Layer_Security
These cryptographic protocols use certificates to communicate with remote servers and exchange security keys before data encryption happens. You can inspect these certificates by clicking on the padlock icon that appears before the https://


Web APIs allow one system to interact with another over HTTP (just like the web).
The system offering the API for use by others is the provider.
The system interacting with the API to accomplish a goal is the consumer.
It is best to prefer the terms provider and consumer over client and server.

```
```javascript Book: Working with Web APIs
Web APIs allow one system to interact with another over HTTP (just like the web).
The system offering the API for use by others is the provider.
The system interacting with the API to accomplish a goal is the consumer.
It is best to prefer the terms provider and consumer over client and server.

APIs allow users of a service to make use of it in new and useful ways.

APIs enable application developers to build their applications on top of a variety of other specialized systems, allowing them to focus on their actual objectives and not worry about all the complexities of every part of the system.

APIs break down the walls between systems, allowing them to share data.
APIs provide an "escape hatch" enabling service users to customize the software's behavior or integrate it into other systems if required.
Many modern web applications provide an API that allows developers to integrate their own code with these applications, taking advantage of the services' functionality in their own apps.

What restrictions does the API place on your use of its data? For example, data from the Amazon Product Advertising API can not be used on mobile devices or TV set top boxes, nor can it be stored for more than 24 hours.
Is the API exposing any data that could be linked back to a person? Many social applications allow access to a user's personal information, and by accessing it, you are taking on the responsibility of keeping this information safe and secure.
Does the API have rate limits, and if so, what are they? Many APIs limit how many requests can be sent from a single user or application within a given time frame. Such restrictions can have an impact on the design of programs that interact with their APIs.

Web APIs are built on top of HTTP, the technology that makes the web work.
HTTP Responses have 3 main parts: status code, headers, and body.
The Content-Type header describes the format of the response body

if you are working with resources on the internet, just use URL.

he final segment, :id, is a placeholder for a value to be filled in later. Any value in a path that begins with a colon in this book should be considered a placeholder. Here are a few other examples:

/api/:version/products/:id
/api/v1/users/:id/profile

/products/:product_id/comments/:id. This form of path can be referred to as nested, because the route for comments, /products/:product_id/comments, is nested underneath the path for a product, /products/:id.

HTML is one of many different media types (also called content types or sometimes MIME types) supported by modern web browsers. It is represented in an HTTP response as the Content-Type header as text/html:

The charset for most requests will be UTF-8 or ISO-8859-1
Other media types include text/plain for plain text responses, text/css for CSS stylesheets, application/javascript for JavaScript files, and many, many more. There are media types for PDF documents, sound files, videos, ZIP archives, and many, many, more.

APIs are generally used to allow systems to communicate by passing structured data back and forth. The content of most requests will use a format and media type that works well for representing hierarchical data. These formats are known as data serialization formats.

A data serialization format describes a way for programs to convert data into a form which is more easily or efficiently stored or transferred. The stored or transferred data can then be converted back into the original data at any time by the original program or any other program that can understand its format.

XML (or extensible markup language) shares common heritage with HTML: they are both based on an earlier and similar type of markup, SGML. XML is generally stricter than HTML and doesn't handle missing tags or improper nesting. It was fairly common to see XML used with APIs in the past, and while some services continue to support XML, JSON has become much more common.
<address>
    <street>1600 Pennsylvania Ave NW</street>
    <city>Washington</city>
    <state>DC</state>
    <zipcode>20500</zipcode>
    <country>Unites States</country>
</address>

JSON (or JavaScript Object Notation) is perhaps the most popular data serialization format used by web APIs today. The syntax JSON uses is based on the way object literals are written in JavaScript, the ubiquitous scripting language of the web. While JSON's popularity is partially due to being based on existing web technologies, a distinction it shares with XML, it is also the result of JSON being a simpler and less ambiguous format.
{
  "street": "1600 Pennsylvania Ave NW",
  "city": "Washington",
  "state": "DC",
  "zipcode": "20500",
  "country": "United States"
}

Media types describe the format of a response's body.
Media types are represented in an HTTP response's Content-Type header, and as a result, are sometimes referred to as content types.
Data serialization provides a common way for systems to pass data to each other, with a guarantee that each system will be able to understand the data.
JSON is the most popular media type for web APIs and the one this book will focus on.

The term REST is often used to describe a set of conventions for how to build APIs. REST stands for representational state transfer, and it was originally defined by Roy Fielding in his doctoral dissertation in 2000. Let's take this term apart:

representational refers to how a representation of a resource is being transferred, and not the resource itself.
state transfer refers to how HTTP is a stateless protocol. This means that servers don't know anything at all about the clients, and that everything the server needs to process the request (the state) is included in the request itself.
The basic ideas behind REST were based on observations about how the web already worked. From this, Fielding derived a set of formalized patterns about the kind of interactions that take place on the web. Loading web pages, submitting forms, and using links to find related content all factor into what REST is and how it applies to the web and API design. If you think about the web page as being a resource this makes a little more sense.

Consider the act of creating, editing, and deleting your user profile on a social network. Doing so might involve loading some forms, entering some values, and sending the new information back to the server. Let's put this into a table to make it easier to see, adding in a few more steps for a more complete example and add the HTTP methods and paths used by the browser to accomplish each step:

Action	HTTP Method	Path	Params
Load new profile page	GET	/profiles/new
Submit filled out profile form to server	POST	/profiles	email=ramenfan@gmail.com&password=iluvnoodles
View new profile page (and notice a typo)	GET	/profiles/1
Load edit profile page	GET	/profiles/1/edit
Submit profile changes to server	POST	/profiles/1	email=ramenfan2@gmail.com&password=ireallyluvnoodles
View new profile page (and decide to delete your profile)	GET	/profiles/1
Click the delete button and delete profile	POST	/profiles/1	_method=delete
Other than possibly being the shortest-lived user profile ever, this is a pretty realistic list of steps. The same actions could be performed with an API instead of using HTML forms, although there would be a few differences:

HTML forms must be loaded before they can be submitted. APIs don't have forms, so this initial GET request is unnecessary.
HTML forms only support two of the many HTTP methods, GET and POST. APIs are able to take advantage of all HTTP methods, which helps clarify the purpose of API requests.
A good way to think about REST is as a way to define everything you might want to do with two values, what and how:

What: Which resource is being acted upon?
How: How are we changing / interacting with the resource?
Nearly all interactions with a RESTful API can be defined in this way. In the case of editing a user profile, the resource (the what) is a user profile. The how depends on what action is being taken.


CRUD is an acronym that is used to describe the four actions that can be taken upon resources:

Create
Read
Update
Delete

Also, take a look at the final step. See how the resource (Placement) and the path (/orders/:id/placement) are both singular? This is what is called a singular resource or singleton resource. Paths and URLs for singular resources identify a single resource. Any of the routes in the table that include an :id placeholder are really singular resources since they identify single resources. In the case of /orders/:id/placement, it looks a little different because the path does not end with an /:id placeholder. This kind of resource is common when there can only be one of that resource. In this case, there can only be a single Placement for each order.

REST is a set of conventions about how to build APIs.
RESTful APIs consist of CRUD actions on a resource
By limiting actions to CRUD, REST requires thinking in a resource-oriented way.
It is worth being as RESTful as possible, but there are times when it is not the best solution.

Signs a URL is for a collection:

The path ends in a plural word, such as example.com/products
The response body contains multiple elements
Signs a URL is for a single element:

The path ends in a plural word, a slash, and then what could be an identifier (which could be numeric or alphabetic)
The response body contains a single element
Summary
APIs provide access to single resources (elements) or groups of resources (collections).
The path for an element is usually the path for its collection, plus an identifier for that resource.

https://id.heroku.com/signup/www-home-top
https://github.com/gotealeaf/web_store
https://github.com/gotealeaf/web_store

http --print=H GET http://book-example.herokuapp.com/v1/products/1 Accept:application/json

The Accept Header for this last request was correctly set to application/json.

Summary
HTTP requests include a path, method, headers, and body.
The Accept header tells the provider what media types can be used to respond to the request.

HTTP Request Side Effects
All of the requests we've made to the web store server have been GET requests. GET requests, by definition, should not alter the resources they are performed against. There can, however, be other side effects. One example of this is a simple hit counter that increments each time a page is loaded. As a result, even though making GET requests is generally considered "safe" in that no data is being explicitly altered on the remote end, it is always worth considering what effects the requests you make could be having on the remote system.

$ http -a admin:password POST book-example.herokuapp.com/v1/products name="Purple Pen" sku="purp100" price=100
HTTP/1.1 201 Created
Connection: close
Content-Length: 56
Content-Type: application/json
Date: Tue, 23 Sep 2014 18:15:23 GMT
Status: 201 Created

{
    "id": 4,
    "name": "Purple Pen",
    "price": 100,
    "sku": "purp100"
}

HTTP requests don't always complete successfully. A failure can be due to a request being incomplete or containing an invalid value, a problem on the server, or even a network connection disruption.

Sometimes there will be no information beyond an error status code; in these situations, the best course of action is to reread any relevant documentation and look for example code that could offer clues.

Missing or Invalid Parameters
Most systems have a set of requirements that must be met to allow the creation of resources. A store might require a price for every product or an email in the correct format for every customer. These kind of restrictions, or validations, are used to ensure all data in the system is valid and complete.
// CONNECTION: This is related to SQL and how we query a database and it will require certain data not require other data. It is an extra layer of validation as well.
Programs are dependent on the structure, format, and type of data in order to operate correctly. A store that allowed users to place orders would need to know the price of each item, how many were available for sale, and if there were any limits on how many a single customer could purchase at once. If the price was missing for a product or had been set to a value that didn't make sense for computing an order total (such as something non-numeric like a string), it is likely that the program would break, preventing a customer from successfully creating an order.

The web store server validates the values provided when creating a product resource using its API. Most often, the documentation for an API will describe what attributes are required when creating a resource and if there are any other requirements that need to be met. The web store is no exception to this, and its documentation describes all three attributes as being required

This is a very different response than what we received when sending all of the parameters. Let's look at some of the important differences:

The status is 422 Unprocessable Entity. Since the code is in the 4xx format, we know the request was not successful. Unprocessable Entity is a cryptic way of saying the request was invalid in a way that prevented the server from working with it. This is often caused by a validation error.
The body is in JSON format, but instead of being the representation of a product, it is an error message. The message string contains an explicit list of problems with the request: name is missing, sku is missing, sku is invalid, price is missing.

Missing Resources
A very common error is attempting to access a resource that doesn't exist. The corresponding HTTP status code for this error is 404 Not Found. We can receive this type of error by trying to fetch a product we know doesn't exist from the web store:

a few common causes for this type of error when working with APIs:

The resource might not actually exist. It could have been deleted or perhaps it was never there in the first place. Verify that any parameters in the request are correct, especially identifiers.
The URL could be incorrect. APIs can have a variety of different URL schemes, from the simple and short to the long and complex. Be sure to look in the documentation for the API you are working with to see what hosts and paths to use. Keep in mind that services with different environments for testing and production will often have a unique URL for each environment.
Accessing the requested resource may require authentication. In an ideal world, these errors would use a more accurate HTTP status code of 401 or 403, but for security reasons, it is sometimes better to only expose the existence of a resource to those who are authorized to access it.

Authentication
We briefly worked with authentication earlier in this chapter while creating a product. Many systems require authentication on some or all of their APIs. For the most part, missing authentication credentials will receive 401, 403, or 404 errors, and can be resolved by sending valid credentials.

Incorrect Media Type
There are multiple ways to send parameters along with a web request. Since JSON has emerged as the most common format for API requests and responses in newly released APIs, HTTPie automatically converts any parameters into JSON when sending a request. HTTPie doesn't print out the request by default, but we can change this behavior and see what is going on.

HTTPie can print out the entire request using the --print flag. A value of HBhb tells HTTPie to print out the headers and body for both the request and response:

The Content-Type is application/json; charset=utf-8. This means that parameters will be sent in JSON format and all text will use the UTF-8 encoding.
The body is indeed represented in JSON.

Rate Limiting
Making a request to an API server requires the receiving system to do some work in order to return a response. Unlike the requests performed by human users of websites, who click links relatively slowly, APIs are usually consumed by automated systems. Just as it is easy to write a simple loop in a programming language that does something thousands of times in just a few seconds, it is just as easy to make thousands of requests to a remote API in an equally short period of time. Since many APIs have to support many users at the same time, the possibility of there being too many requests to handle becomes extremely likely.

Most APIs address these by enforcing rate limiting. This means that each API consumer is allotted a certain number of requests within a specified amount of time. Any requests made beyond these limits are sent an error response and not processed further. The status code of responses to rate limited requests varies by service, but it is often 403 Forbidden.

When encountering these rate-limiting errors, it is often enough to simply perform the request less often. If the same request is being made over and over, the response can be stored locally to reduce the number of requests being made.

Server Errors
The errors we've looked at so far are all in the format 4xx, and they can all be described at a high level as client errors. They are the result of the client doing something in a way that is incompatible with the server. It is also possible for errors to occur on the server that are not a direct result of anything a client does. These errors will be in the format 5xx, and have many potential causes, such as:

A bug or oversight in the server implementation. Sometimes these can result from the correct and intended usage of an API.
A hardware or other infrastructure problem with the remote system.
Any other error that was not foreseen by the remote server implementors.
Some APIs even return 5xx errors when a specific client error would be more accurate and useful.

Unlike client errors, resolving a server error is usually not useful as an API consumer. Since server errors can be intermittent, simply retrying the request after a bit of time is often worth attempting. If the server errors continue, though, it is best to stop making requests until the remote system has been fixed. Continuing to make requests to a remote system returning errors can worsen many problems and should be avoided.

Making a change to this product is going to be very similar to creating a product, with two main differences:

Using PUT as the HTTP method instead of POST
Using the product's path instead of the product collection path (e.g. /products/1 instead of /products)
PUT is the correct HTTP method for updating the value of a resource and sending all of its values back to the server. PUT tells the server to put this resource in this place. According to the HTTP spec, PUT requests must take a complete representation of the resource being updated. This means that if a parameter was required to create the resource, it is required to be sent in any PUT requests modifying that resource. This also means that any parameter left out of a PUT request is assumed to have an empty value (usually null or nil). Most APIs don't strictly follow this requirement, however, and provide a much simpler behavior by updating any parameters sent in a PUT request, and not modifying any other parameters that are already on the resource. This is technically the behavior of another HTTP method, PATCH, which we won't get into in this book as it is new and not yet widely used.

We can see from the response that the name and sku of the product remain unchanged and the price has been updated to 150. Multiple values can be changed at once by sending them at the same time
$ http -a admin:password PUT book-example.herokuapp.com/v1/products/5 name="New and Improved Purple Pen" sku="newp100"
HTTP/1.1 200 OK
Connection: close
Content-Length: 73
Content-Type: application/json
Date: Thu, 02 Oct 2014 05:45:21 GMT
Status: 200 OK

{
    "id": 5,
    "name": "New and Improved Purple Pen",
    "price": 150,
    "sku": "newp100"
}

Delete resource
$ http book-example.herokuapp.com/v1/products/4
HTTP/1.1 404 Not Found
Connection: close
Content-Length: 75
Content-Type: application/json
Date: Thu, 02 Oct 2014 05:56:43 GMT
Status: 404 Not Found

{
    "message": "Couldn't find WebStore::Product with 'id'=5",
    "status_code": 404
}
204 No Content is in the format 2xx, which means the request was processed successfully. 204 No Content is commonly used when it doesn't make sense to return anything in the response body, and deleting a resource is one such case. If there is no longer a resource at the path being accessed, there isn't anything to send back.

Although we have no reason not to trust the web store API, we can attempt to fetch the product that was just deleted to see if there is still a resource at its path:

$ http book-example.herokuapp.com/v1/products/4
HTTP/1.1 404 Not Found
Connection: close
Content-Length: 75
Content-Type: application/json
Date: Thu, 02 Oct 2014 05:56:43 GMT
Status: 404 Not Found

{
    "message": "Couldn't find WebStore::Product with 'id'=5",
    "status_code": 404
}

Reading Documentation
The first step of working with any API is collecting a few pieces of information:

What protocol, host and path (basically, what URL) will provide access to appropriate resource?
What parameters do I need to include in the request?
Is authentication required?
https://dev.twitter.com/rest/public

What is OAuth?
OAuth is a complicated system that provides a way for users to grant access to third party applications without revealing their credentials. The basic flow begins with a user clicking a button that says something along the lines of Connect your Service Account. The user is then redirected to the service's site where they approve the originating application's access and is then redirected back to that site. There are also a few interactions happening directly between the servers that are not exposed to the user. The end result of this is an access token and an access token secret, which, when combined with an application key and application secret belonging to the requesting application, provide enough information to build a request using a somewhat involved list of steps we won't get into here.

You can think of the application key and application secret as the applications username and password, and the access token and access token secret as the username and password belonging to an individual user. These values are used for different purposes, but ultimately you need all four values to make requests.

Ultimately, OAuth provides a decent way for users to authorize access to their account without giving out their credentials, and it can be a fairly smooth experience for end users using a desktop web browser. Implementing all the functionality to make it work can be a lot of work for a developer, although there are libraries available for many programming languages that can make this process much more manageable.

Twitter has also provided another way to create OAuth tokens for use in developing new applications, allowing us to skip most of those steps by providing us an access token and access token secret for development purposes. We will be using these values throughout this chapter in order to focus on working with the Twitter API and not the particulars of OAuth.

https://github.com/Mashape/mashape-oauth/blob/master/FLOWS.md

https://en.wikipedia.org/wiki/Cross-origin_resource_sharing

Allow
Used with a 405 Method Not Allowed response to a request with an invalid HTTP method. The value of this header lists what methods are allowed.

Copy Code
$ http --print=h POST www.google.com
HTTP/1.1 405 Method Not Allowed
Allow: GET, HEAD
...

ETag
Copy Code
ETag: "6df23dc03f9b54cc"
Used to identify a specific version of a resource. Any changes to the resource will result in a new value for ETag

X-* Headers
Naming headers with names beginning with X- is a convention for headers that aren't standardized. These headers are often API or application-specific. GitHub uses some of these headers to provide the status of rate limiting with each request:



```
```javascript Network Programming in JavaScript
There are two things worth noting about how this interaction differs from the page-navigation example shown above:

The web browser doesn't make an automatic HTTP request; instead, JavaScript code initiates it, typically from an event listener.
When the browser receives a response, JavaScript code optionally takes the response's body and updates the page as needed. Note that the JavaScript code is free to ignore the response.

Single Page Applications
As client-side software development has become more involved, it has become increasingly common to make HTTP requests outside the main HTML page load. Some modern applications fetch data in a serialized format and create the DOM entirely from JavaScript running in a client's browser. We call these applications single page applications since they often run entirely within a single HTML page. Instead of fetching bits of HTML generated by a server, this model does all interactions by passing data to and from the server, often encoded as JSON.


```
```javascript Making a Request with XMLHttpRequest
Making a Request with XMLHttpRequest
Use the XMLHttpRequest object to send a HTTP request with JavaScript. This object is part of the browser API, not the JavaScript language. The name comes from its original use, which was to fetch XML documents over HTTP. Today, we use this object to load any data (typically HTML or JSON) and can use other protocols (including file://) as well.

To send a request, we must provide the same parameters we would use when sending an HTTP request from any other language or tool: a method, a host, and a path.

Copy Code
let request = new XMLHttpRequest(); // Instantiate new XMLHttpRequest object
request.open('GET', '/path');       // Set HTTP method and URL on request
request.send();                     // Send request

The above code sends a GET request for /path from the local host (the host that runs the above code). The request object has some interesting properties. Before the request completes, though, those properties contain empty string or 0:

Copy Code
let request = new XMLHttpRequest();
request.open('GET', '/path');
request.send();

request.responseText;                       // => ""
request.status;                             // => 0
request.statusText;                         // => ""

Once the request completes, these properties have values that describe the results:

Copy Code
request.responseText;                       // body of response
request.status;                             // status code of response
request.statusText;                         // status text from response

request.getResponseHeader('Content-Type');  // response header

request.readyState;                         // more on this later...

XMLHttpRequest object uses event listeners to send notifications when the request completes and provides access to the response returned by the remote system. Here, we'll wait for the response to load by listening for the load event:

Copy Code
request.addEventListener('load', event => {
  var request = event.target;                 // the XMLHttpRequest object

  request.responseText;                       // body of response
  request.status;                             // status code
  request.statusText;                         // status text from response

  request.getResponseHeader('Content-Type');  // response header

  request.readyState;                         // more on this later...
});

An Overview of XMLHttpRequest Methods
You should become familiar with how to use the following XMLHttpRequest methods:

Method	Description
open(method, url)	Open a connection to url using method.
send(data)	Send the request, optionally sending along data.
setRequestHeader(header, value)	Set HTTP header to value.
abort()	Cancel an active request.
getResponseHeader(header)	Return the response's value for header.
You should also become familiar with the following XMLHttpRequest properties:

Property	Writable	Default Value	Description
timeout	Yes	0	Maximum time a request can take to complete (in milliseconds)
readyState	No		What state the request is in (see below)
responseText	No	null	Raw text of the response's body.
response	No	null	Parsed content of response, not meaningful in all situations


```
```javascript XMLHttpRequest Events
let request = new XMLHttpRequest();

request.addEventListener('load', event => {
  let xhr = event.target;   // the request is available as event.target
                            // if you can't access it from an outer scope.
});

Event	Fires When...
loadstart	Request sent to server
loadend	Response loading done and all other events have fired. Last event to fire.
Before loadend triggers, another event will fire based on whether the request succeeded:

Events	Fires when...
load	A complete response loaded
abort	The request was interrupted before it could complete
error	An error occurred
timeout	A response wasn't received before the timeout period ended

Event	Fires when...
readystatechange	The value of readyState changes
progress	Response data is received in some situations.


```
```javascript Data Serialization
Request Serialization Formats
JavaScript applications that run in a web browser must serialize data when communicating with remote systems. Serialization lets both the client and server transfer data in a format that preserves information without interfering with the communication protocol. Applications can use any data serialization format that both the client and server know how to read and write.

Let's examine some of these formats. We'll use the following data to illustrate the differences:

{
  "title": "Do Androids Dream of Electric Sheep?",
  "year": 1968
}

Query String / URL Encoding
Many web applications use a serialization format that you've already seen and used: URL encoding for query strings. A query string consists of one or more name=value pairs separated by the & character. This format is easy to use and understand, though the presence of non-alphanumeric characters in the names or values can complicate matters. You must encode those characters. For example, you can encode spaces in a query string as either %20 or +.

JavaScript provides a built-in function, encodeURIComponent, that lets you encode a name or value using this format. You can then combine the name-value pairs with =, and combine the resulting strings with &. Name-value pairs can be used both as part of a URL and in the body of a POST request.

Copy Code
# without encodeURIComponent
title=Do Androids Dream of Electric Sheep?&year=1968

# with encodeURIComponent
title=Do%20Androids%20Dream%20of%20Electric%20Sheep%3F&year=1968
Once you have a properly encoded query string, you can append it to a GET request's path:

GET RequestCopy Code
GET /path?title=Do%20Androids%20Dream%20of%20Electric%20Sheep%3F&year=1968 HTTP/1.1
Host: example.test
Accept: */*

URL encoding also works with POST requests, but you must include a Content-Type header with a value of application/x-www-form-urlencoded in that case. Place the encoded name-value string in the request body.

POST RequestCopy Code
POST /path HTTP/1.1
Host: example.test
Content-Length: 54
Content-Type: application/x-www-form-urlencoded; charset=utf-8
Accept: */*

title=Do%20Androids%20Dream%20of%20Electric%20Sheep%3F&year=1968

Multipart Forms
POST requests use multipart form formats for forms that include file uploads or that use FormData objects to collect data. This format isn't strictly an encoding format since we don't encode anything. Instead, we place each name-value pair in a separate section of the request body. A boundary delimiter defined by the Content-Type request header separates each part:

Copy Code
Content-Type: multipart/form-data; boundary=----WebKitFormBoundarywDbHM6i57QWyAWro
Below is an entire POST request that uses multipart form data. Notice how each parameter is in a separate part of the request body, with the boundary delimiter before each section, and after the last section. The Content-Type header also sets multipart/form-data and specifies the boundary delimiter:

Copy Code
POST /path HTTP/1.1
Host: example.test
Content-Length: 267
Content-Type: multipart/form-data; boundary=----WebKitFormBoundarywDbHM6i57QWyAWro
Accept: */*

------WebKitFormBoundarywDbHM6i57QWyAWro
Content-Disposition: form-data; name="title"

Do Androids Dream of Electric Sheep?
------WebKitFormBoundarywDbHM6i57QWyAWro
Content-Disposition: form-data; name="year"

1968
------WebKitFormBoundarywDbHM6i57QWyAWro--
Note that the final boundary delimiter has an extra -- at the end; these characters mark the end of the multipart content.

JSON Serialization
JSON (JavaScript Object Notation) is a popular data serialization format used by APIs. It's used by programs written in different languages to exchange arrays, objects, strings, numbers, and boolean values over the network.

JSON does not provide native support for complex data types like dates and times. Instead, you must represent such values in a format that both the client and server understand; strings, numbers, and objects work well for this in most cases.

A GET request can return JSON, you may then use POST to send JSON data to the server. Here we make our request using JSON format:

Copy Code
POST /path HTTP/1.1
Host: example.test
Content-Length: 62
Content-Type: application/json; charset=utf-8
Accept: */*

{"title":"Do Androids Dream of Electric Sheep?","year":"1968"}
Note that the Content-Type header has a value of application/json; charset=utf-8. This is required if you want to use JSON as the request serialization format. The server may not parse the request correctly if this header has the wrong value.

Content-Type and charset

The charset is optional, but it's best practice to include it except when using multipart form format. Providing the charset ensures that the server interprets the data with the correct encoding. You can use charset=utf-8 in most cases, meaning that the data uses the UTF-8 character encoding.
```
```javascript Example: Loading HTML via XHR
<h1>Existing Page</h1>

<div id="store"></div>
We'll use the JavaScript below to fetch the list of products from a web store and insert it in the div with an id of store:

Copy Code
document.addEventListener('DOMContentLoaded', () => {
  let request = new XMLHttpRequest();
  request.open('GET', 'https://ls-230-web-store-demo.herokuapp.com/products');

  request.addEventListener('load', event => {
    let store = document.getElementById('store');
    store.innerHTML = request.response;
  });

  request.send();
});// I LOVE HOW I UNDERSTAND WHAT THE ABOVE CODE IS DOING!!

<h1>Existing Page</h1>

<div id="store"></div>

document.addEventListener('DOMContentLoaded', () => {
  let store = document.getElementById('store');

  let request = new XMLHttpRequest();
  request.open('GET', 'https://ls-230-web-store-demo.herokuapp.com/products');

  request.addEventListener('load', event => store.innerHTML = request.response);
  request.send();

  store.addEventListener('click', event => {
    let target = event.target;
    if (target.tagName !== 'A') {
      return;
    }

    event.preventDefault();

    let request = new XMLHttpRequest();
    request.open('GET', 'https://ls-230-web-store-demo.herokuapp.com' + target.getAttribute('href'));

    request.addEventListener('load', event => store.innerHTML = request.response);
    request.send();
  });
});
In this assignment, we've learned two important concepts:

We can use an XMLHttpRequest object to fetch content and insert it in an existing web page without a full page reload.
We can attach event listeners to content embedded in the page to circumvent the browser's default behavior and create custom interactions.


```
```javascript Example: Submitting a Form via XHR

There are three steps to submitting a form using JavaScript:

Serialize the form data.
Send the request using XMLHttpRequest.
Handle the response.
Steps 2 and 3 will be similar to what we've done so far for GET requests. Here's the JavaScript code used to make a POST request to a book-catalog demo application:

Copy Code
let request = new XMLHttpRequest();
request.open('POST', 'https://example.test/path');

let data = 'this is a test';

request.send(data);

// Or if there was no data to send
// request.send();


URL-encoding POST Parameters
URL encoding also works with POST requests, but you must include a Content-Type header with a value of application/x-www-form-urlencoded when you do. Place the encoded name-value string in the request body. Here we post a new book to a book-catalog demo application.

Copy Code
let request = new XMLHttpRequest();
request.open('POST', 'https://ls-230-book-catalog.herokuapp.com/books');

request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");

let data = 'title=Effective%20JavaScript&author=David%20Herman';

request.addEventListener('load', () => {
  if (request.status === 201) {
    console.log(`This book was added to the catalog: ${request.responseText}`);
  }
});

request.send(data);
A 201 status means the resource was added successfully on the server, although our book-catalog application doesn't actually store the data.

Submitting a Form
Let's assume we are working with a web page that contains the following form:

Copy Code
<form id="form">
  <p><label>Title: <input type="text" name="title"></label></p>
  <p><label>Author: <input type="text" name="author"></label></p>
  <p><button type="submit">Submit</button></p>
</form>
To access the values from this form, we can use the HTMLFormElement.elements property within an event listener that receives control when the user submits the form:

Copy Code
let form = document.getElementById('form');

// Bind to the form's submit event to handle the submit button
// being clicked, enter being pressed within an input, etc.
form.addEventListener('submit', event => {
  // prevent the browser from submitting the form
  event.preventDefault();

  // access the inputs using form.elements and serialize into a string
  let keysAndValues = [];

  for (let index = 0; index < form.elements.length; index += 1) {
    let element = form.elements[index];
    let key;
    let value;

    if (element.type !== 'submit') {
      key = encodeURIComponent(element.name);
      value = encodeURIComponent(element.value);
      keysAndValues.push(`${key}=${value}`);
    }
  }

  let data = keysAndValues.join('&');

  // submit the data
  let request = new XMLHttpRequest();
  request.open('POST', 'https://ls-230-book-catalog.herokuapp.com/books');
  request.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

  request.addEventListener('load', () => {
    if (request.status === 201) {
      console.log(`This book was added to the catalog: ${request.responseText}`);
    }
  });

  request.send(data);
});

Submitting a Form with FormData
URL-encoding the names and values of each input element as we did above is a manual and error-prone process. Modern browsers provide a built-in API to assist in this process, FormData. Here's how to use it:

Please take note that FormData only uses input fields that have a name attribute.

Copy Code
let form = document.getElementById('form');

form.addEventListener('submit', event => {
  // prevent the browser from submitting the form
  event.preventDefault();

  let data = new FormData(form);

  let request = new XMLHttpRequest();
  request.open('POST', 'https://ls-230-book-catalog.herokuapp.com/books');

  request.addEventListener('load', () => {
    if (request.status === 201) {
      console.log(`This book was added to the catalog: ${request.responseText}`);
    }
  });

  request.send(data);
});

ne thing to note is that FormData uses a different serialization format called multipart. Forms that include file inputs use this same serialization. Since FormData can upload files, it makes sense for it to default to this multipart format.

The HTTP request sent by the above code looks like this:

HTTP RequestCopy Code
POST /books HTTP/1.1
Host: ls-230-book-catalog.herokuapp.com
Content-Length: 234
Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryf0PCniJK0bw0lb4e
Accept: */*

------WebKitFormBoundaryf0PCniJK0bw0lb4e
Content-Disposition: form-data; name="title"

Effective JavaScript
------WebKitFormBoundaryf0PCniJK0bw0lb4e
Content-Disposition: form-data; name="author"

David Herman
------WebKitFormBoundaryf0PCniJK0bw0lb4e--
The body of requests sent using multipart form serialization contains a series of parts. Each section is prefixed by a string (in this case, ------WebKitFormBoundaryf0PCniJK0bw0lb4e), and includes an HTTP header called Content-Disposition that provides the name of a parameter and its value. Here's one part of the above request for illustration:

Copy Code
------WebKitFormBoundaryf0PCniJK0bw0lb4e
Content-Disposition: form-data; name="author"

David Herman
The body of the request terminates with the same boundary string followed by two dashes (in this case, ------WebKitFormBoundaryf0PCniJK0bw0lb4e--).


document.addEventListener('DOMContentLoaded', () => {
  let store = document.getElementById('store');

  ...

  store.addEventListener('submit', event => {
    event.preventDefault();

    let form = event.target;
    let request = new XMLHttpRequest();
    let data = new FormData(form);

    request.open('POST', `https://ls-230-web-store-demo.herokuapp.com${form.getAttribute('action')}`);

    request.addEventListener('load', event => store.innerHTML = request.response);
    request.send(data);
  });
});

document.addEventListener('DOMContentLoaded', () => {
  let store = document.getElementById('store');

  ...

  store.addEventListener('submit', event => {
    let form = event.target;

    event.preventDefault();
    let request = new XMLHttpRequest();

    let data = new FormData(form);

    request.open('POST', `https://ls-230-web-store-demo.herokuapp.com${form.getAttribute('action')}`);
    request.setRequestHeader('Authorization', 'token AUTH_TOKEN');

    request.addEventListener('load', event => store.innerHTML = request.response);
    request.send(data);
  });
});
```
```javascript Example: Loading JSON via XHR
Sometimes, though, it makes more sense to load data in a primitive data structure and render it with the client-side code. This situation often occurs when the user interface has widgets that the server doesn't render.

In a previous assignment, we used the following code to load some JSON data from GitHub:

{}
let request = new XMLHttpRequest();
request.open('GET', 'https://api.github.com/repos/rails/rails');

request.addEventListener('load', event => {
  let data = JSON.parse(request.response);

  // do something with data
});

request.send();

let request = new XMLHttpRequest();
request.open('GET', 'https://api.github.com/repos/rails/rails');
request.responseType = 'json';

request.addEventListener('load', event => {
  // request.response will be the result of parsing the JSON response body
  // or null if the body couldn't be parsed or another error
  // occurred.

  let data = request.response;
});

request.send();
//
let request = new XMLHttpRequest();
request.open('GET', 'http://ls-230-book-catalog.herokuapp.com/invalid_book');

request.addEventListener('load', event => {
  try {
    let data = JSON.parse(request.response);
    // do something with the data
  } catch(e) {
    console.log('Cannot parse the received response as JSON.')
  }
});

request.send();
Write some JavaScript code that loads JSON data from https://api.github.com/repos/rails/rails, parses the JSON into a JavaScript object, and then logs the HTTP status code and the number of open issues to the console.
let request = new XMLHttpRequest();
request.open('GET', 'https://api.github.com/repos/rails/rails');

request.addEventListener('load', event => {
  let data = JSON.parse(request.response);
  console.log(request.status);
  console.log(data.open_issues);
});

request.send();

Extend the code from the previous exercise to log the message 'The request could not be completed!' to the console when the request produces an error. You may replace the url in the previous exercise to "hts://api.github.com/repos/rails/rails" so that the error handler will be triggered.
let request = new XMLHttpRequest();
request.open('GET', 'htps://api.github.com/repos/rails/rails');

request.addEventListener('load', event => {
  let data = JSON.parse(request.response);
  console.log(request.status);
  console.log(data.open_issues);
});

request.addEventListener('error', event => {
  console.log('The request could not be completed!');
});

request.send();


```
```javascript Example: Sending JSON via XHR
Sending JSON data to the server is similar to submitting a form. You use the same three steps, with a couple of adjustments:

Serialize the data into valid JSON.
Send the request using XMLHttpRequest with a Content-Type: application/json; charset=utf-8 header.
Handle the response.
We'll go through these differences one at a time.

Serializing Data to JSON
Let's review how to send a basic POST request from JavaScript:

Copy Code
let request = new XMLHttpRequest();
request.open('POST', 'https://ls-230-book-catalog.herokuapp.com/books');

let data = 'title=Eloquent%20JavaScript&author=Marijn%20Haverbeke';

request.send(data);
To send data in JSON format, we must update the code to create a valid JSON string.

Copy Code
let request = new XMLHttpRequest();
request.open('POST', 'https://ls-230-book-catalog.herokuapp.com/books');

let data = { title: 'Eloquent JavaScript', author: 'Marijn Haverbeke' };
let json = JSON.stringify(data);

request.send(json);
The serialized JSON data looks like this:

Copy Code
{"title": "Eloquent JavaScript", "author": "Marijn Haverbeke"}

Setting the Content-Type Header
The second step is to set the Content-Type request header to application/json; charset=utf-8, which tells the server to expect JSON data. It's up to the server to do the right thing here, and not all will change their behavior based on the value of this header, but many APIs require that you set this value accurately; it's a good habit.

Copy Code
let request = new XMLHttpRequest();
request.open('POST', 'https://ls-230-book-catalog.herokuapp.com/books');

request.setRequestHeader('Content-Type', 'application/json; charset=utf-8');

let data = { title: 'Eloquent JavaScript', author: 'Marijn Haverbeke' };
let json = JSON.stringify(data);

request.send(json);

Write out the raw text of the HTTP request the last example above will send to the server.
POST /books HTTP/1.1
Host: ls-230-book-catalog.herokuapp.com
Content-Type: application/json; charset=utf-8
Accept: */

{"title": "Eloquent JavaScript", "author": "Marijn Haverbeke"}

Write some JavaScript to create a new product by sending a request to the JSON API on our web store. To create a product, make a POST request to https://ls-230-web-store-demo.herokuapp.com/v1/products. To make the post request, you'll need the following:

Content-Type header set to application/json; charset=utf-8
Authorization header set to token AUTH_TOKEN
json object with with the following properties:
name
sku (must have 3 or more characters)
price (must be an integer greater than 0)
function createProduct(productData) {
  let json = JSON.stringify(productData);
  let request = new XMLHttpRequest();

  request.open('POST', 'https://ls-230-web-store-demo.herokuapp.com/v1/products');
  request.setRequestHeader('Content-Type', 'application/json; charset=utf-8');
  request.setRequestHeader('Authorization', 'token AUTH_TOKEN');

  request.addEventListener('load', () => {
    console.log(`This product was added: ${request.responseText}`);
  });

  request.send(json);
}

createProduct({
  name: 'HB pencil',
  sku: 'hbp100',
  price: 50,
});



```

```javascript Cross-Domain XMLHttpRequests with CORS
The scheme, hostname, and port of a web page's URL define its origin. A cross-origin request occurs when the page tries to access a resource from a different origin.

Let's consider the URL http://mysite.com/doc1. If the web page from this URL requests a resource from any of the following URLs, it will be considered a cross-origin request.

https://mysite.com/doc1 (different scheme/protocol)
http://mysite.com:4000/doc1 (different port)
http://anothersite.com/doc1 (different host)
A cross-origin request could be a request for an image, a JavaScript file, an XHR, or any other resource. The most important kind of cross-origin request for our purposes is a cross-domain request: a request from one domain (hostname) to another domain.

Cross-domain requests in web browsers have security vulnerabilities that hackers can exploit to launch attacks. These attacks often lure a user into clicking a carefully crafted link that sends a request to an application with the user's login credentials. These security issues are beyond the scope of our discussion here. Search XSS and CSRF if you're interested in finding out more about these attacks.

Cross-Origin requests with XHR
By default, an XHR object can't send cross-origin requests because of the aforementioned security problems. All browsers implement a security feature called the same-origin policy. It prevents XMLHttpRequest from making cross-domain requests. The application can request resources from the origin domain, but a request from any other domain causes an error.

You might ask how you can use all the APIs available for public consumption on web applications if cross-origin requests from XHR objects aren't allowed? Indeed, many applications do use APIs for weather information, stocks, sports scores, maps and all kinds of other services hosted at different domains. The answer is that they use the Cross-Origin Resource Sharing (CORS) mechanism to allow cross-origin access to resources.

CORS
Cross-Origin Resource Sharing is a W3C specification that defines how the browser and server must communicate when accessing resources across origins. The idea behind CORS is to let the two systems know enough about each other to determine whether the response should succeed or fail. Applications use custom HTTP request and response headers to implement this mechanism.

According to the specification, every XMLHttpRequest sent by the browser must have an Origin header that contains the origin of the requesting page. The server uses this header to determine whether it should send a corresponding header in the response.

The browser automatically adds the Origin header as part of an XHR. For example, if we send an XHR from a page hosted at http://localhost:8080, the browser adds the following request header:

Copy Code
Origin: http://localhost:8080
When the server receives this request, it checks the Origin header and determines whether the request came from an origin that is allowed to see the response. If it is, it sends the response back with an Access-Control-Allow-Origin header that contains the same origin. In our example, the response header will be:

Copy Code
Access-Control-Allow-Origin: http://localhost:8080
If the server wants to make a resource available to everyone, it can send the same header, but with a value of *:

Copy Code
Access-Control-Allow-Origin: *
When the browser sees the Access-Control-Allow-Origin header, it checks whether the value contains the correct origin or *. If it does, the browser makes the response available to the application. Otherwise, it raises an error.

It's important to note that even if the server sends the correct response, but without the Access-Control-Allow-Origin header with the appropriate value, the browser will raise an error and not let the script access the response.

<!DOCTYPE html>
<html lang="en">
<head>
  <title>Document</title>
</head>
<body>
  <script type="text/javascript">

    function getAreasOfContinents() {
      let xhr = new XMLHttpRequest();

      xhr.addEventListener('load', () => {
        console.log('Areas of continents received!')
        console.log(xhr.response);
      });

      xhr.responseType = 'json';
      xhr.open('GET', 'http://localhost:3000/areas_of_continents');
      xhr.send();
    }
  </script>
</body>
</html>

Now that both servers are running on different terminals, it's time to send some cross-origin requests. Navigate to localhost:8080 in the browser to load the index.html file. Open the Developer Tools console and invoke getAreasOfContinents. If the script has no other errors, you'll see an error message like this (the exact message varies by browser):

Copy Code
XMLHttpRequest cannot load http://localhost:3000/areas_of_continents. No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://localhost:8080' is therefore not allowed access.
Switch to the "Network" tab of the Developer Tools, and select the request with the name areas_of_continents. You'll see that the request headers include the Origin header but the response headers don't have an Access-Control-Allow-Origin header. The browser received the response, but it concealed the data from us since the response didn't have the header required by CORS.

To make the response accessible to the client application, we'll make a small change to our route in /routes/index.js. Specifically, we'll add an Access-Control-Allow-Origin header to our response. For our first try, we'll identify the wrong origin so we can see what happens.

/routes/index.jsCopy Code
router.get('/areas_of_continents', (req, res, next) => {
  // code omitted for brevity
  res.set('Access-Control-Allow-Origin', 'http://example.com');
  res.json(continents);
});
Restart the node app after making this change, then call getAreasOfContinents from the console of index.html. The error message changes:

Copy Code
XMLHttpRequest cannot load http://localhost:3000/areas_of_continents. The 'Access-Control-Allow-Origin' header has a value 'http://example.com' that is not equal to the supplied origin. Origin 'http://localhost:8080' is therefore not allowed access.
This time the response does have the required header, but the value is not equal to the requesting origin. Let's fix this by giving the header the value that it needs to make the response body accessible to http://localhost:8080.

/routes/index.jsCopy Code
router.get('/areas_of_continents', (req, res, next) => {
  // code omitted for brevity
  res.set('Access-Control-Allow-Origin', 'http://localhost:8080');
  // the following line also works
  // res.set('Access-Control-Allow-Origin', '*');
  res.json(continents);
});
This time, calling getAreasOfContents logs the parsed JSON received from the server.

Conclusion
The Cross-Origin Resource Sharing specification fulfills the need for legitimate cross-origin requests. It gives us a standard way to access resources from different origins without the security problems associated with cross-origin requests.


```
Project: Search Autocomplete, Part 1 - Introduction and Setup
```javascript Project: Search Autocomplete, Part 2 - Setting up the UI
The first thing to note about this code is the call to Autocomplete.init inside the event DOMContentLoaded event handler, which ensures that the DOM is ready before the code that manipulates it runs.

Inside init, we create two properties of the Autocomplete object: input is the input element that we'll build the autocomplete functionality around, while url is the URL that fetches the JSON data. Next, we call two methods, wrapInput and createUI.

The wrapInput method wraps the text input inside a div element with a class of autocomplete-wrapper.

The createUI method creates two DOM elements as siblings of the text input. The first is a ul element with a class of autocomplete-ui. We'll populate this element later with the list of countries that we get back as a response from our local server. For now, we store it in the listUI property of the Autocomplete object.

The second element that we create inside createUI is another div with a class of autocomplete-overlay. We'll use it as an overlay on top of the text input; it will contain the country name that best matches the query. We assign this element to the overlay property of the Autocomplete object.

Let's be a little more explicit about the properties on our Autocomplete object. It's a good practice to explicitly set the initial state of an object in a method like our init method. We'll set the overlay and listUI properties to null inside init.


```
Project: Search Autocomplete, Part 3 - Talking to the server
Project: Search Autocomplete, Part 4 - Improving User Experience
Project: Search Autocomplete, Part 5 - Throttling XHR requests
```javascript
https://launchschool.com/exercise_sets/e0015dad
```
# JavaScript Libraries
Douglas Crockford Lecture: The Metamorphosis of Ajax https://www.youtube.com/watch?v=Fv9qT9joc0M
```javascript Reading Documentation
https://medium.com/launch-school/just-in-time-learning-f6a10886ddfe

The core components of JIT learning are:

A solid grasp of programming fundamentals
Understanding how to learn

Different Types of Documentation
An important thing to understand is that there are different types of documentation. Some types of documentation will be more useful than others at certain times and in particular contexts.

General Overview
When first encountering a new library, or assessing it for potential use, you initially want a general idea of what the library does, as well as getting a feel for whether it might be a good fit for your intended use-case. The best place to head at this stage is any kind of overview page or introductory section.

Taking the Handlebars docs as an example, the very first sub-section of the Introduction page provides a good, high-level overview of what the library is and what is does. It:

Explains what Handlebars is (a simple templating language)
Provides a basic mental model for how it works (it uses a template and an input object to generate HTML, or other text formats)
Shows a basic syntax example, with a brief explanation of that syntax
This is probably sufficient information to form a very basic overview of the library. If we need to delve deeper, the page then goes on to explain the installation process, and describe various features, with each section providing links to more detailed documentation.

Tutorials and How-to Pages
Once you've got a clear idea of what the library does, and you feel that it might be a good fit for your intended use-case, the next step is basic familiarization with the library. At this stage it's probably a bit too early to dive straight into the API Reference and start using the library for your project. Doing so can potentially be overwhelming, since you lack sufficient context for how the library works and how to use it. A good way to build this context is by working through any generic usage examples and basic tutorials that might be provided. Screencasts, videos, articles, quick-start guides, and FAQ pages can also fall into this category.

Tutorials and How-to pages differ from each other slightly in terms of scope and objective. Tutorials tend to focus on learning a particular concept. How-to pages guide you through the steps required to achieve a specific goal. The Selecting Elements page of the jQuery documentation is a good example of the former. Compare this to the How do I select an item using class {} or ID? page from the FAQ section of jQuery docs, which illustrates the latter type. What both these types of documentation have in common, is that they focus on practical understanding rather than theoretical knowledge.

Not all library documentation has these types of tutorial or how-to pages, but if they do you should take advantage of them. The other extreme is large libraries that provide super-detailed tutorials for every feature. In this case, you'll need to be a bit selective and focus only on the specific features that you intend to use for your project.

Sometimes you may need to hunt around for this type of documentation. The jQuery library, for example, hosts what it refers to as its Learning Center on a separate sub-domain to its API Reference.

API Reference
In contrast to tutorials and how-to guides, the API reference of a library is information-oriented, and concerned with theoretical rather than practical knowledge. Think of it as a dictionary for the library you are using. Just as you probably wouldn't sit down and read an English language dictionary from cover to cover, there's no need to read and memorize the entire API reference.

Instead, you should consult the API reference when actually using the library for a project; for example, if you need to know what a specific function {} or method does, or understand its syntax. Here are some practical steps you can take in terms of how to maximize your use of the API reference.

Learn the structure of the API reference

Reference docs will usually group methods in a particular way, with a list of the groupings often displayed in a sidebar. Having a high-level view of the different groupings, and the types of methods they contain can help when navigating the reference or searching for a particular method or function. {}

Although not always the case, API reference docs will often group methods by module or class. The lodash docs are a good example of this type of structure
Some docs may use a different structure. For example, the jQuery API reference groups methods by their functionality (DOM selection, DOM manipulation, Events, etc) https://api.jquery.com/
Become familiar with the style and layout of syntax definitions

Although there will be variations between documentation for different libraries, many tend to follow a fairly consistent pattern in terms of what they include in a syntax definition:

A general description of what the method or function does {}
Any arguments or parameters that the method or function has, and whether these are optional or required
The return value of the method or function {}
One or more code examples (be aware that these code examples generally won't show every variation in usage for a method or function)
Leverage existing mental models
https://lodash.com/docs/4.17.15
Functions and methods provided by libraries are often abstractions of fundamental concepts that you may already be familiar with. That being the case, you can leverage existing mental models about those concepts to understand how a particular function or method works. For example, if you read the description for the jQuery on() [method(https://api.jquery.com/on/):

Attach an event handler function for one or more events to the selected elements.

This very closely resembles our understanding of the Web API addEventListener() method covered in an earlier lesson in this course. There are some differences between the two, but in terms of general mental model it's a useful comparison.

Trying Things Out
Sometimes documentation can be confusing initially. Once you've gained more familiarity with the library and how it works, the docs can start to make more sense

If you want to use a library for a big project, it can sometimes be useful build something small with it first, perhaps but with similar features to your main project, in order to get used to the library as well as its documentation.

This practical approach can also be useful when exploring individual functions or methods. Rather than immediately including that method in a large program with lots of other code, first try out the method in isolation to become familiar with it. You could create a small code file for this purpose, or use an online tool such as CodePen.

An approach of trying things out and then relating the results back to the documentation is particularly useful if the documentation is sparse, or poorly written.

Other Tips
Check the version. Well established libraries will often have evolved through multiple versions. When this is the case, the documentation will usually be versioned accordingly. Make sure that you are reading the version of the documentation which matched the version of the library you are using.

Use documentation as to inform decision making. If you are comparing multiple different libraries for the same function within a particular project, research the docs first. Sometimes the choice of using one library versus another will come down to how well written and easy to use the documentation is.

We'll be working with a few different libraries throughout the remainder of this lesson. As we do so, take the time to explore the documentation for each one. Compare and contrast the style, layout, and quality of each.


```
```javascript Including an External Library
In order to make use of a library in your client-side code, you need to include that library in the web page(s) where it is going to be used.

Hosting the Files Locally
One option is to download the file(s) for the library and host them locally. Locally in this context means on the same server where the HTML files are hosted. In projects that use external libraries, it's common to organise the directory structure so that the files for those libraries are kept in a separate directory within your javascripts directory, perhaps something like this (we're using jQuery here as an example):

Copy Code
├── index.html
├── img
├── css
├── js
│   ├── app.js
│   └── vendor
│       └── jquery.js
As with any external JavaScript code, you would then reference the file using a <script> tag in the <head> of your HTML file:

Copy Code
<!doctype html>
<html lang="en">
   <head>
      <title>My Awesome Project</title>
      <script src="/js/vendor/jquery.js"></script>
   </head>
   <body>

   <!-- rest of html -->

Using a CDN
A popular option when including a JavaScript library in your project, is to use a Content Distribution Network (CDN). Some libraries, such as jQuery, host their own CDNs. Other CDNs, such as Google's provide access to a number of popular libraries. Whichever CDN you choose to use, you will usually get a choice of versions, and whether to use compressed and minified files or not.

The set-up when using a CDN is exactly the same except that the value of the src attribute of the <script> tag will be the URL to the file on the CDN:

Copy Code
<!doctype html>
<html lang="en">
   <head>
      <title>My Awesome Project</title>
      <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
   </head>
   <body>

   <!-- rest of html -->
Order is Important
One important thing to note is that you should place the <script> tag for the library before any script tags where that library is used, for example:

Copy Code
<!doctype html>
<html lang="en">
   <head>
      <title>My Awesome Project</title>
      <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
      <script src="/js/app.js"></script> <!-- we can use jQuery in our app.js file -->
      <script>
        // we can use jQuery here
      </script>
   </head>
   <body>

   <!-- rest of html -->

```
```javascript jQuery
The idea behind jQuery was to create an abstraction layer that took care of all these workarounds for us.

Adherence to standards and modern browser APIs mean that we now can accomplish most of what jQuery does with vanilla JavaScript, without having to write complex hacks and workarounds.

It's important to note that jQuery is not a separate language from JavaScript, but a library of functions and methods that abstract away JavaScript functionality. At its core, jQuery is still JavaScript. With a good foundation of JavaScript and DOM knowledge, it's much easier to understand what a library like jQuery does. As you work through the various assignments on jQuery in this lesson, try to relate its functionality back to the concepts we covered in those earlier lessons. Think about how you can accomplish the same functionality without jQuery, and how that would make the code different.

At its core, jQuery is a function that wraps a collection of DOM elements and some convenience methods into an object. You can call the function to select the elements you need to process, and manipulate the object or its elements with methods built into the object.

What is the jQuery function? Internally, it is a function that works with an argument that you pass to it.

If the argument is a string or a DOM element, it wraps a collection of jQuery objects and returns them.
If the argument is a function, jQuery uses that function as a callback when the document is ready. (We'll discuss what this means a little later in this assignment).
While you can use the name jQuery when calling jQuery, it's common practice to use the alias $ instead. Either way, we pass the function a string that resembles a CSS selector. For example, if we have a div with an id of content, we can pass jQuery the string "#content":

Copy Code
var $content = jQuery('#content');
var $sameContent = $('#content');

In our examples, we use the Airbnb-recommended style of prefixing names that reference jQuery objects with a $ so we can instantly distinguish them from other (non-jQuery) objects.

Collections
Suppose you want to act on all the list items on the page. As we mentioned earlier, the return value of jQuery is a collection. When we use an ID selector, the collection contains at most one element; with other selectors, it can be any size.

Copy Code
var $lis = $('li');
The returned object is the same type of object as returned by $("#id"); both are collections.

If you have, say, three list items on your page, you can verify that the above code selected all three by checking the length property of the jQuery collection $lis:

Copy Code
console.log($lis.length);   // -> 3

The jquery Property
If you're unsure whether a variable or property references a jQuery object, you can check the jquery property:

Copy Code
console.log($content.jquery);
If the property exists and is a version number that matches the jQuery version, you know that you're dealing with an object produced by jQuery.

The DOM Ready Callback
Since most of jQuery acts on DOM elements, we must wait for the page to load before we execute our code. jQuery has that covered as well. Meet the DOM ready callback:

Copy Code
$(document).ready(function() {
  // DOM loaded and ready, referenced image on img tags are not ready
});
The callback function we pass to ready executes after the document, and its dependencies, finish loading. Note, though, that ready doesn't wait for the browser to load images included via <img> tags. In some cases, you must delay execution until the window finishes loading:

Copy Code
$(window).load(function() {
  // DOM loaded and ready, referenced image on img tags loaded and ready
});
Typically, you can wait for the DOM ready event before running your code. If it uses the natural image dimensions, though, you must wait for the window load event instead.

There's an even shorter way to write a DOM ready callback. You can skip traversing the document and binding to its ready event by passing a callback function directly to the jQuery function, $():

Copy Code
$(function() {
  // DOM is now loaded
});

jQuery Object Methods
Once you obtain an object from jQuery, you can perform a variety of tasks with it. You can, for example, change the font-size for all of the elements represented by the object with the css method:

Copy Code
$content.css('font-size', '18px ');
Note that you must pass a string value for the second argument of css and that you must include the measurement units when appropriate.

Getters and Setters
We often use the term setter method to refer to methods that set properties for an object. We also use the term getter method to refer to methods that retrieve the current values for a property. Some jQuery methods, including css, have both setter and getter forms: if you omit the last argument, the method acts as a getter; otherwise, it acts as a setter.

Copy Code
console.log($content.css('font-size'));    // getter
$content.css('font-size', '18px');         // setter
Likewise, the width and height methods act as both getters and setters. To check the $content object's width, call width. To set it to half that width, we use the same method with the new width.

Copy Code
var width = $content.width();  // 800 (getter)
$content.width(width / 2);     // Sets to 400
console.log($content.width()); // now 400 (getter)
Note that width and height return and use numeric values.

Chaining Method Calls

Suppose we want to set multiple CSS properties on the same element. We could write multiple calls to the method starting with the $content variable:

Copy Code
$content.css('font-size', '18px');
$content.css('color', '#b00b00');
Repetitive code like this is tedious and error prone when working with more than a couple of properties. We can take advantage of the fact that most jQuery methods return an object that contains jQuery methods, which means you can chain calls together:

Copy Code
$content.css('font-size', '18px').css('color', '#b00b00');
That's easier to write, but it's still tedious. Let's look at the jQuery documentation to see if there's a better way.
http://api.jquery.com/css/#css-properties

Object Argument

As with most jQuery methods, there are multiple ways to call css. One intriguing alternative uses an Object with key/value pairs that match up with the CSS property/value pairs you want to give the element, which lets you set any number of CSS property/value pairs at once. Thus, we can rewrite our code like this:

Copy Code
$content.css({
  'font-size': '18px',
  color: '#b00b00'
});

Property Name Syntax

Note that we quoted the font-size property name here, but didn't do that for color. Since font-size contains a hyphen that JavaScript tries to interpret as subtraction, we can't write font-size without quotes; the quotes prevent JavaScript from trying to process - as the subtraction operator.

If this syntax annoys you, jQuery also accepts camel case property names instead. Whenever you have a CSS property that includes one or more hyphens, you can omit the hyphens and capitalize the next letter instead. For font-size, for example, you can use fontSize instead:

Copy Code
$content.css({
  fontSize: '18px',
  color: '#b00b00'
});
Likewise, you can use backgroundColor instead of "background-color", and borderWidth instead of "border-width".

You can use most CSS selectors as-is to access elements with jQuery, though you may need to "escape" some special characters. JQuery also provides a bunch of selectors that are unique to jQuery. You can view all available selectors here.

Convenience Methods
jQuery also provides a variety of convenience methods directly attached to the jQuery object. If you need to check what type a variable is, you can use methods like $.isArray and $.isFunction. You can concatenate two arrays using $.merge, or make a new array with $.map. The most important method of the jQuery object is the $.ajax method, which lets you make AJAX requests in a much easier fashion than if you had to support multiple versions of Internet Explorer on your own. We'll get to AJAX a bit later.

Explore the Documentation
Take some time to explore the jQuery Learning Centre, and become familiar with the structure of the API reference. The idea here isn't to learn jQuery inside-out, but to form a mental model for what jQuery is and how it works. Focus in particular on the jQuery Object.

jQuery is a very fully-featured library, and offers a broad range of functionality. In some later assignments in this lesson, we'll explore some particular aspects of the functionality, specifically DOM traversal and manipulation, jQuery events, and jQuery Ajax.

```
```javascript Read: jQuery DOM Traversal
This is when you would use the closest method. There is one very important difference in how this method works compared to parent. With parent, it never looks at the current element for consideration. With closest, it first looks at the current element to see if it is a match. That means that if we were to start with our $('p') collection and look for the .closest('p'), we'd get the same elements as what we already have in our collection. Be sure to keep this in mind when using closest to avoid any unwanted behavior.

The closest method is very useful for finding the first ancestor element that meets the criteria passed to the method.

This will grab the next closest ul, and not the outermost parent ul. If we wanted to grab all parent ul elements, there's a more comprehensive method called parents that will continue all the way out to the root element. Change the closest method call to parents and you'll see that we add the "categories" class to both uls.{}

Copy Code
$('#javascript').parents('ul').addClass('categories');

Looking Inwards from an Object
Instead of going outward to find the uls, let's now start at the outermost ul and find all of the list items.

One extremely useful method is the find method. You can call it on an existing jQuery object to traverse to one of its child elements using another CSS-like selector.

alert($('ul#navigation').find('li').length);  // Should be 4

Now we'd like to collect only the immediate children lis from the navigation ul. We can use the children method either with or without a selector, just like the parent method. Since our HTML is well-formed, we know that the only elements that will be immediate children will be lis and we won't have to pass in a selector.

Copy Code
alert($('#navigation').children().length);  // Should be 1

Finding Sibling Elements
The methods outlined so far will cover almost all of your traversing using jQuery objects. Sometimes, however, you may want to do something like grab all of the sibling elements that come after the current one and perform some action on them. The nextAll method will return all siblings after, with an optional selector passed in. There's a complementary method called prevAll that goes in the opposite direction. And if you needed all the siblings, rather than grabbing the parent and then getting all its children, you could simply use siblings with an optional selector.

Copy Code
// Find all list items after the CSS list item and hide them
var $css = $('#css').closest('li');
$css.nextAll().hide();

// Find all list items before the CSS list item and hide them
$css.prevAll().hide();

// Find all sibling lis and show them
$css.siblings().show();
The next() and prev() methods get a single sibling element, either immediately after or immediately preceding the current one.

Use a descendant selector to find all the list items in the article element.
$('article li');

Find the third list item from the article element.
$('article li').eq(2);

Find the table element, then find all the odd-numbered table rows in that element.
$('table').find('tr').filter(':odd');
// or
$('table').find('tr:odd');

Find the list item that contains the text ac ante, then locate the parent li element.

Hint
Solution
Copy Code
$('li li').filter(":contains('ac ante')").parents('li');
// or
$("li li:contains('ac ante')").parents('li');

Find the list item that contains the text ac ante, then find and return the next element.
$("li li:contains('ac ante')").next();

Find all the table cells in the table, then find the last cell from the collection.
$('table td').last();
// or
$('table td').eq(-1);

Find all the table cells that do not have a class of "protected".
$('td').not(".protected");
// or
$('td:not(".protected")');

Find all the anchor elements that have an href value that begins with #.
$('a[href^=#]');

Find all elements that have a class name that contains "block".
$('[class*=block]');
```
Practice Problems: Using jQuery Selectors
```javascript Read: jQuery Events
A Simple Click Handler
We'll start with a click event on anchors. Create three anchors with different text contents. The href attribute you provide doesn't matter since we'll tell the browser that it shouldn't follow the href when the user clicks the link. By convention, we set href to # when we do this.

Copy Code
<ul>
  <li><a href="#">Apples</a></li>
  <li><a href="#">Bananas</a></li>
  <li><a href="#">Oranges</a></li>
</ul>
With the above code, we can use a click event listener to invoke a click handler when the user clicks one of the links. We'll use the on method to register a click handler, as with any other event. First, use jQuery to find the anchors, then call the on method on it:

Copy Code
$(function () {
  $("a").on("click", function () {});
});

The on method, like most jQuery methods, has more than one calling format. The call shown above uses the most common format; the first argument is the event type and the second argument is the function that will be called when the event fires. When the user clicks a link, JavaScript will call the event handler. Right now, this code doesn't do anything, though; if we click a link, our location changes to include the # sign that is in the href attribute, but that behavior is provided by the browser. Ideally, we want to prevent the browser from trying to follow the links at all. To do that, we'll call a method on the event object passed to our callback function.

The event object has a wealth of information on the current event. The object includes the event type, the target of the event, some event-specific information such as the mouse position, and some methods, preventDefault and stopPropagation. You may recall from earlier in the course, that stopPropagation stops the event object from continuing its path along the capturing and bubbling phases, and preventDefault tells the browser that it shouldn't perform any actions that it might otherwise perform in response to a user's action.

We'll use preventDefault to stop the browser from following the links:

Copy Code
$("a").on("click", function (event) {
  event.preventDefault();
});

 There are three ways to do this: use the target attribute or the currentTarget attribute on the event object (note: target and currentTarget have the same value since the element clicked is the one that the handler is attached to), or use the value of this within the callback. We'll use the latter.

Any of the techniques returns a DOM element. Since this isn't a jQuery object, we have to pass it through the jQuery function to wrap it with jQuery's convenience methods. We'll store the jQuery object in a local variable so we can get the anchor's text.

Copy Code
$("a").on("click", function (event) {
  event.preventDefault();
  let $anchor = $(this);
});
We now need to find the paragraph and replace its content with the text of the clicked anchor. We can use jQuery's text() method to perform the text replacement. We use this method twice in the example below: to get the text content of the $anchor object, and to set the text content of the $p object.

Copy Code
$("a").on("click", function (event) {
  event.preventDefault();
  let $anchor = $(this);
  let $p = $("p");
  $p.text($anchor.text());
});

let $p = $("p");

$("a").on("click", function (event) {
  event.preventDefault();
  let $anchor = $(this);
  $p.text($anchor.text());
});

let $p = $("p");

$("a").on("click", function (event) {
  event.preventDefault();
  let $anchor = $(this);
  $p.text("Your favorite fruit is " + $anchor.text());
});

<ul>
  <li><a href="#">Apples</a></li>
  <li><a href="#">Bananas</a></li>
  <li><a href="#">Oranges</a></li>
</ul>

<form action="#" method="post">
  <fieldset>
    <input type="text">
    <input type="submit" value="Choose">
  </fieldset>
</form>

<p>Choose your favorite fruit!</p>

$("form").on("submit", function (event) {
  event.preventDefault();
  let $input = $(this).find("input[type=text]");
  $p.text("Your favorite fruit is " + $input.val());
});

Refactoring
We're using the same text for output with both the anchor clicks and the form submits, which means we have to remember to update it in two places if we later need to change it. Instead, we should set a variable once and reuse it in both of the listeners. Here's our finished Javascript code:

Copy Code
$(function () {
  let $p = $("p");
  let OUTPUT = "Your favorite fruit is ";

  $("a").on("click", function (event) {
    event.preventDefault();
    let $anchor = $(this);
    $p.text(OUTPUT + $anchor.text());
  });

  $("form").on("submit", function (event) {
    event.preventDefault();
    let $input = $(this).find("input[type=text]");
    $p.text(OUTPUT + $input.val());
  });
});

Convenience Methods
jQuery has convenience methods for many events. These methods have the same name as the event types and let us bind listeners to the events less verbosely. Here's our code rewritten with the click and submit convenience methods.

Copy Code
$(function () {
  let $p = $("p");
  let OUTPUT = "Your favorite fruit is ";

  $("a").click(function (e) {
    e.preventDefault();
    let $event = $(this);
    $p.text(OUTPUT + $event.text());
  });

  $("form").submit(function (e) {
    e.preventDefault();
    let $input = $(this).find("input[type=text]");
    $p.text(OUTPUT + $input.val());
  });
});

jQuery Event Delegation
When you have an event handler that is being bound to a large number of elements that all exist within the same container, it's more efficient to delegate the event handling to the parent element rather than bind it to each element individually. Think of a list of 30 items, each of which includes a link to delete the item from the list. If we used an event bound directly to the anchor, there will be 30 events bound. This may not slow down our page that much, but if we have larger and larger sets of elements that all use the same event handler, we'll have a very inefficient application that will be prone to slowdowns.

Copy Code
<ul>
  <li>
    <p>Bananas</p>
    <a href="#">Remove</a>
  </li>
  <!-- 29 more list items, each with a remove anchor -->
</ul>
Copy Code
// This callback is bound to each anchor, making 30 event handlers in memory

$("a").on("click", function (e) {
  e.preventDefault();
  $(this).closest("li").remove();
});

Instead, we would attach the same event to the parent unordered list element. Then we would only have one event listener that could then check for which anchor was clicked and perform our processing from there.

Copy Code
// This callback is bound to a single element, yet it is able to process
// click events on any of the remove anchors within it.

$("ul").on("click", "a", function (e) {
  e.preventDefault();
  $(e.target).closest("li").remove();
});

https://medium.com/@sak1986/event-binding-in-jquery-daf902be7c58


```
```javascript Practice Problems: jQuery Events
Before we bind the event, though, we will need to first unbind any previous keypress event that was bound. jQuery has a complimentary method called "off" that allows you to unbind an event by its type.

If we don't unbind, there will eventually be multiple keys that can toggle the accordion. By unbinding any previous keypress event, we are making it so that only the key that is currently set can toggle.

Copy Code
$(document).off('keypress');
Since one of the biggest benefits to using jQuery is to be able to chain methods together, we can chain our event binding onto our unbinding.

Copy Code
$(document).off('keypress').on('keypress', function() {
Now there will only be one keypress event listener at a time on the document.

The Keypress Event Callback
Within the event callback, to check whether or not the correct key was pressed, we would check a property on the event object that is passed in. The key property will tell you which key was pressed. This is where your previously stored character comes in. Check to see if the key property is different than the saved character, and if so stop the event from processing further by using a return statement like this:

Copy Code
if (e.key !== character) {
  return;
}
The return statement will stop the event handler from doing any more of its processing, since the key that was pressed was not the one we were looking for.

After our if statement, we know that the correct key was pressed. We can now toggle the accordion element. Use jQuery to find the accordion element by its ID, then call a built-in animation method called slideToggle. This will figure out whether or not the accordion is visible for you and animate its visibility by sliding the bottom edge of the element up or down.

Preventing Form Submission
Now that we have bound the keypress event within our form's submit event, we need to remember to prevent the form from submitting. Change the callback function to accept the event object as an argument. At the top of the submit event callback, call preventDefault(); on that event object to stop the form from submitting.

Copy Code
$('form').on('submit', function(e) {
  e.preventDefault();
  // ...
});
Triggering a Different Event
Our final event needs to be bound to the anchor element. Bind a click event to the anchor, and use the same method as the submit event to prevent the default behavior of the anchor. In our callback, we could duplicate the slideToggle that happens in our keypress event, but instead we should consider having the toggle only in one place. Then if something changes later on, like the ID we are using, we only have one place we need to make an update to. What we can do instead is to move the slideToggle from the keypress event to this one, then our keypress event can trigger the click event on this anchor. Take your accordion slideToggle line from the keypress event and move it to this click event callback. Now go back to the spot in the keypress event callback that you removed the slideToggle from and instead write a jQuery selector to find the anchor. When you've found it, you can then call trigger("click") on the anchor. This will trigger the event that you give to it, meaning that the anchor's click event callback will run and the slideToggle will occur.

Copy Code
$('a').trigger('click');
The trigger method can be called with any of the events, and if the event exists it will call the callback. As a result, we have eliminated the need for repeating our code.

Now you should have an understanding of how to remove an event callback using off and how to trigger a different event using trigger. Both will become very useful as you work on more involved projects that use jQuery events.

<!doctype html>
<html lang="en-US">
  <head>
    <title>jQuery Selectors</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="style.css" />
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    <script>
      $(function() {
        $("form").on("submit", function(e) {
          e.preventDefault();
          var character = $("#key").val();

          $(document).off("keypress").on("keypress", function(e) {
            if (e.key !== character) { return; }
            $("a").trigger("click");
          });
        });

        $("a").on("click", function(e) {
          e.preventDefault();
          $("#accordion").slideToggle();
        });
      });
    </script>
  </head>
  <body>
    <main>
      <form action="" method="get">
        <fieldset>
          <h1>Type a key to toggle the accordion with</h1>
          <input type="text" id="key" name="key" maxlength="1" />
          <input type="submit" value="Set" />
        </fieldset>
      </form>
      <p><a href="#">Toggle accordion</a></p>
      <div id="accordion">
        <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>
      </div>
    </main>
  </body>
</html>
```
```javascript HTML Templating With JavaScript
There are many versions of client-side templating libraries out there, from Mustache to Underscore. Each has varying syntaxes and may include or omit features. Mustache, for example, does not include a way to add logic to your HTML templates. Underscore templates allow you to write plain old JavaScript within your template to be executed when it renders. There's another popular library that falls somewhere in between, adding logic and support for templates, but keeping the JavaScript out of the HTML. This library is Handlebars.

Handlebars can be used on its own. It has no dependencies of any kind, meaning that whether or not you are using jQuery, or an MVC framework, or anything else client-side, you can use Handlebars for your templating.

Handlebars uses a fast and complex method of string replacement that will allow you to write the names of properties of your objects within handlebars and have them replaced with the property values. Handlebars templates allow you to have property names surrounded by two opening and closing curly braces, {{ }}. Using our above example, the Handlebars template for a product would look like this:

Copy Code
<li>
  <h3>{{name}}</h3>
  <dl>
    <dt>Quantity:</dt>
    <dd>{{quantity}}</dd>
    <dt>Price:</dt>
    <dd>${{price}}</dd>
  </dl>
</li>
These handlebars properties can be placed anywhere within the HTML string. If we wanted to output the quantity as the value of a data attribute on the list item, we could add the attribute and use a handlebars property inside the attribute value.

Copy Code
<li data-quantity="{{quantity}}">
Handlebars also has the ability to check properties for whether or not they are truthy values. A Handlebars conditional is false if the property value is false, undefined, null, '', 0 or an empty array. This means that we can add a condition to our template that will render the sale indicator if the on_sale property is a true value. With any Handlebars-executed template code, we prefix it with a # sign. This tells Handlebars to perform an action at this point in our template before rendering.

Copy Code
<li>
  <h3>{{name}}</h3>
  <dl>
    <dt>Quantity:</dt>
    <dd>{{quantity}}</dd>
    <dt>Price:</dt>
    <dd>
      ${{price}}
      {{#if on_sale}}
      <strong>SALE!</strong>
      {{/if}}
    </dd>
  </dl>
</li>

This is known as the if helper. There are other built-in helpers in Handlebars, and they all start with a # sign and end with a closing element. The if helper also has an {{else}} section that can be used. Note that it does not have a # sign in front of it. Handlebars has already been notified that the contents of the #if block should be treated differently, so it knows to look for this {{else}} keyword and treat it as the alternate condition rather than as a property that is to be output.

How do we use this to output our items, though? In Handlebars, we would use template pre-compilation to create and store a function that can be called to build our template based on an object passed into it. The Handlebars library gives us an object named Handlebars that holds the methods we will need to create templates and partials. To create a template function, we would use the compile method to provide it an HTML string that we want to use as our template.

Handlebars allows for template reuse through partials. Partials are normal Handlebars templates that may be called directly by other templates (read more).

Just like we did in the previous assignment, we can create a template in our HTML using a script element. If we give the element a type attribute of something other than text/javascript, the browser won't try to execute it as JavaScript. We'll use a type of text/x-handlebars to wrap our template in a script element. We'll add an id to it to make it easier to locate it with jQuery.

Copy Code
<script id='productTemplate' type='text/x-handlebars'>
  <li>
    <h3>{{name}}</h3>
    <dl>
      <dt>Quantity:</dt>
      <dd>{{quantity}}</dd>
      <dt>Price:</dt>
      <dd>
        ${{price}}
        {{#if on_sale}}
        <strong>SALE!</strong>
        {{/if}}
      </dd>
    </dl>
  </li>
</script>
The Handlebars.compile method converts our HTML into a template function. We can assign the template function to a new variable, productTemplate:

Copy Code
let productTemplate = Handlebars.compile($('#productTemplate').html());
Here we have read the contents of the script element using jQuery's .html method and passed that in to the Handlebars.compile method. We get a function in return that can be passed an object, and the function will return an HTML string with all of the properties filled in.

We can now loop over our products array and write this template using the item. We'll store each template in an array just like before, but we won't have the messy string concatenation and conditional.

Copy Code
let $list = $('ul');
let productsHtml = products.map(function(product) {
  return productTemplate(product);
});

$list.html(productsHtml.join(''));
We can clean this up even further using Handlebars. We have another helper called each that will allow us to write our loop within our template. Just like the if helper, this one is prefixed with the # sign. The each block iterates over an array thats assigned to one of the properties of the object passed to the template. Within the each block, we can then access properties on the current object in the array by simply using the property names as before. When we are done with the each block, we use the closing /each expression.

Copy Code
<script id='productTemplate' type='text/x-handlebars'>
  {{#each items}}
  <li>
    <h3>{{name}}</h3>
    <dl>
      <dt>Quantity:</dt>
      <dd>{{quantity}}</dd>
      <dt>Price:</dt>
      <dd>
        ${{price}}
        {{#if on_sale}}
        <strong>SALE!</strong>
        {{/if}}
      </dd>
    </dl>
  </li>
  {{/each}}
</script>
Our forEach loop can now be replaced with a simple call to our template. We will pass in an object that has an items property on it, and that property will have an array of the products to be rendered.

Copy Code
let productTemplate = Handlebars.compile($('#productTemplate').html());
let $list = $('ul');

$list.html(productTemplate({ items: products }));
This will automatically render a list item for each item in the products array. If we also wanted to output the current index of the loop, we could use the {{@index}} expression within the each block.

What if we wanted to render a single product somewhere in our application? Would we have to duplicate our product template and omit the each loop? Instead of having duplicate code, we can use a partial to render the array of products, then use that partial to render single instances of a product. If we remove the each loop from our product template, we can then create a new template for a products list and reference the product template as a partial from within the each loop.

Copy Code
<script id='productTemplate' type='text/x-handlebars'>
  <li>
    <h3>{{name}}</h3>
    <dl>
      <dt>Quantity:</dt>
      <dd>{{quantity}}</dd>
      <dt>Price:</dt>
      <dd>
        ${{price}}
        {{#if on_sale}}
        <strong>SALE!</strong>
        {{/if}}
      </dd>
    </dl>
  </li>
</script>

<script id='productsList' type='text/x-handlebars'>
  {{#each items}}
  {{> productTemplate}}
  {{/each}}
</script>
The > sign tells Handlebars to look for a partial with the name productTemplate. These partials aren't created automatically, though, so we'll have to register the partial by this name in our JavaScript.

Copy Code
// Compile both templates for use later
let productsList = Handlebars.compile($('#productsList').html());
let productTemplate = Handlebars.compile($('#productTemplate').html());
let $list = $('ul');

// Also register the product template as a partial
Handlebars.registerPartial('productTemplate', $('#productTemplate').html());

// Write the current list to the page
$list.html(productsList({ items: products }));

// Create a new product
let newProduct = {
  name: 'Soup',
  quantity: 1,
  price: 1.29
};

// Render the new product with the product template
$list.append(productTemplate(newProduct));
As you can see, Handlebars can handle a wide variety of situations, and in every case we don't have to write any HTML inside of our JavaScript. Once you get used to dynamically creating HTML with a templating library like this, you will never want to go back to string concatenation!

https://www.sitepoint.com/a-beginners-guide-to-handlebars/

<script id="post" type="text/x-handlebars">
  <article>
    <h1>{{title}}</h1>
    <p><time>Posted on {{published}}</time></p>
    {{body}}
  </article>
</script>

let post = {
  title: 'Lorem ipsum dolor sit amet',
  published: 'April 1, 2015',
  body: 'Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit.'
};

Locate the template by ID and compile it to a template function. Render the post to the body element using the function.//
let postTemplate = Handlebars.compile($('#post').html());

// Using JavaScript
let postTemplate = Handlebars.compile(document.getElementById('post').innerHTML);

$('body').append(postTemplate(post));

Change your post object's body property to contain HTML elements as part of the string. Modify your Handlebars template to allow HTML to be output unescaped.

Solution
Copy Code
post.body = '<p>' + post.body + '</p>';
Copy Code
<script id="post" type="text/x-handlebars">
  <article>
    <h1>{{title}}</h1>
    <p><time>Posted on {{published}}</time></p>
    {{{body}}}
  </article>
</script>

Add a property called tags on the post object that will be an array of strings to represent tags added to the blog post. Use the Handlebars each built-in helper to output all tags for the post.

Solution
Copy Code
post.tags = ['Food', 'Cooking', 'Vegetables'];
Copy Code
<script id="post" type="text/x-handlebars">
  <article>
    <h1>{{title}}</h1>
    <p><time>Posted on {{published}}</time></p>
    {{{body}}}
    <footer>
      <p>
        Tags:
        {{#each tags}}
        <strong>{{this}}</strong>
        {{/each}}
      </p>
    </footer>
  </article>
</script>

Create a separate template for the HTML element that wraps each tag. Using the handlebars partial method, register the template as a partial using the name "tag" and replace the HTML for tags in the main template with a reference to the partial.

Solution
Copy Code
<script id="tag" type="text/x-handlebars">
  <strong>{{this}}</strong>
</script>

<script id="post" type="text/x-handlebars">
  <article>
    <h1>{{title}}</h1>
    <p><time>Posted on {{published}}</time></p>
    {{{body}}}
    <footer>
      <p>
        Tags:
        {{#each tags}}
        {{>tag}}
        {{/each}}
      </p>
    </footer>
  </article>
</script>
Copy Code
Handlebars.registerPartial('tag', $('#tag').html());

Create a posts array, adding the existing post to it. Add a second post with no tags property. Modify your template to check for the existence of tags, and if none exist, output a "Not tagged" message. Wrap the template in an each loop to output each post.

Solution
Copy Code
let posts = [
  {
    title: 'voluptate velit',
    published: 'April 2, 2015',
    body: 'At vero eos et accusamus et iusto odio dignissimos ducimus qui blanditiis praesentium voluptatum deleniti atque corrupti quos dolores et quas molestias excepturi sint occaecati cupiditate non provident, similique sunt in culpa qui officia deserunt mollitia animi, id est laborum et dolorum fuga.'
  }
];
posts.push(post);

let postsTemplate = Handlebars.compile(document.getElementById('posts').innerHTML);

$('body').append(postsTemplate({ posts: posts }));
Copy Code
<script id="posts" type="text/x-handlebars">
  {{#each posts}}
  <article>
    <h1>{{title}}</h1>
    <p><time>Posted on {{published}}</time></p>
    {{{body}}}
    <footer>
      <p>
        {{#if tags}}
        Tags:
        {{#each tags}}
        {{>tag}}
        {{/each}}
        {{else}}
        Not tagged
        {{/if}}
      </p>
    </footer>
  </article>
  {{/each}}
</script>

```
Practice Problems: Handlebars Basics
Assignment: Managing Collections in JavaScript with Handlebars
```javascript AJAX Requests
jQuery Ajax
The syntax for XMLHttpRequest isn't the most concise, and early implementations of XMLHttpRequest had a few cross-browser inconsistencies. jQuery's ajax() method sought to deal with this by providing a simple interface that acts as a wrapper for that complexity.

Take some time to familiarize yourself with the jQuery documentation for Ajax. Make sure to read the Key Concepts and jQuery's Ajax-Related Methods sections, and pay particular attention to the following points:

The way that the ajax() method uses a configuration object to specify the various parameters of the request
The fact that responses are handled by using a callback passed to a method chained to the initial ajax() call
Both of these key points are demonstrated in the example below:

Copy Code
$.ajax({
  url: '/my-blog-post',
  type: "GET",
  dataType : "json",
}).done(function(json) {
  // do something with the returned data
});
The configuration object passed as an argument to the ajax() method invocation sets the url, request type, and dataType for the request.

Note that done() in this context is a method of the jQuery XHR object (jqXHR) which invokes a callback function if the request succeeds. There are equivalent methods to handle other outcomes such as fail() and always().

Don't worry if you don't completely understand this example right now. It should become clearer once you've spent some time with the documentation.

Fetch API
Fetch isn't a library like jQuery, but a Web API like XMLHttpRequest. It lets you make network requests like XMLHttpRequest, but it leverages the Promise syntax to provide a much simpler interface.

The MDN docs provide a good general overview to using Fetch, as well as API documentation.

Pay particular attention to the way that the Fetch API defines Request, Response, and Headers objects as part of its interface, and the properties of those objects.

It may be worthwhile briefly reviewing the assignment on Promises from earlier in the course before working through the Fetch documentation.

A simple example of using Fetch might look something like this:

Copy Code
fetch(
    '/my-blog-post',
    { method: 'GET' }
  ).then((response) => {
    // do something with the response
  });
This may look very similar to our jQuery Ajax example, and there are indeed similarities between the interfaces provided by the two. There are also some key differences to be aware of, including:

The Promise that fetch() returns won't reject if the response status is an HTTP error status code (i.e. response codes in the 4xx and 5xx ranges)
By default, fetch() won't send cookies. In order to send cookies with the request, the credentials parameter must be set to either include, or same-origin. The latter option sends credentials only if the request URL is on the same origin as the calling script.

Which to Use?
As you've seen, there are plenty of options for making Ajax requests: XMLHttpRequest, fetch(), and jQuery's ajax(). In addition, there are also specialist libraries such as axios, which offers a similar feature set and browser support to jQuery Ajax, but leverages the Promises syntax in a similar way to the Fetch API.

So, which option should you use?

The answer, as is often the case, is it depends. Each option has it's pros and cons, and may be suitable for one project but not another.

For simple Ajax requests, XMLHttpRequest may be sufficient. For requests that need to handle lots of conditions, its use of callbacks can lead to code that is complex and difficult to parse.

The Promise-based syntax used by Fetch provides a much simpler interface. There are various caveats to consider if wanting to use Fetch, in particular browser support. Fetch is a relatively new API, and is well supported in most modern browsers. If your project needs to support older browsers, such as an older version of IE, it may not be a suitable option (though you can still potentially use it by using the Fetch polyfill, along with a Promises polyfill).

If your codebase already uses a library like jQuery for other features, then using jQuery Ajax for Ajax request is probably a reasonable choice. For new projects, there's a wider discussion to be had about whether to use a library like jQuery at all.

There are also specialist HTTP clients and libraries that might be a suitable option for any Ajax functionality of your project.

The key thing when is to develop a solid mental model for what these options do and how they work, and combine that with an ability to read documentation and do research. This will enable you to quickly ramp up on a particular library or API, and also put you in a good position to identify the differences between them and weight up their various pros and cons.

In the next lesson of this course, you'll work on a number of projects where you'll need to make Ajax requests. This will provide an opportunity to further research and try out some of these different options.

Summary
In this lesson, we explored the concept of using JavaScript libraries as part of the development process. The key take-away here shouldn't be remembering the specific functions and methods that those libraries provide, but instead to have a high level understanding of what these libraries can do and the role that they can play within your front-end development workflow.

Use documentation efficiently to ramp up quickly on a new library or API when you need to use it for a particular project.

Use Developer Tools built in to the browser as part of your work-flow to test and debug your front-end code.

At its core, jQuery is a function that wraps a collection of DOM elements and some convenience methods into an object.

jQuery provides methods for many aspects of front-end development, such as interacting with the DOM, managing browser events, and making Ajax calls.

Handlebars is a minimal templating library which allows you to easily add and update sections of a web page.

The Fetch API and jQuery's ajax() are alternatives to XMLHttpRequest for making Ajax calls. At a high level they all do the same thing: make a HTTP request and then process the response once it is received.


```

# Putting it All Together
```javascript Chrome Debugging Tools for Front End Development
https://developers.google.com/web/tools/chrome-devtools

```
```javascript HTML Data Attributes
You may see some people use ID attributes to achieve this, but that's not really the purpose of ID attributes. Instead, you can create your own attributes and set their values to match the custom attributes on the content blocks. With the introduction of HTML5 came the ability to create custom data attributes. These attributes can be added to any HTML element, and they bear no significance other than to store data for you. Data attributes always start with data- and need at least one character after the hyphen, but what comes after the hyphen can be anything. The value you give to the attribute can also be anything that can be contained within a string. Let's use this markup as an example:

<ul>
  <li><a href="#" data-block="gold">Gold Sponsors</a></li>
  <li><a href="#" data-block="silver">Silver Sponsors</a></li>
  <li><a href="#" data-block="bronze">Bronze Sponsors</a></li>
</ul>

<article data-block="gold">
  <h1>Gold Sponsors</h1>
</article>

<article data-block="silver">
  <h1>Silver Sponsors</h1>
</article>

<article data-block="bronze">
  <h1>Bronze Sponsors</h1>
</article>

In our JavaScript code, we could read the value of the data-block attribute on the link we clicked and find the article element with the same value. If we reorder the tabs, our articles can stay in the same order and everything still works. If we used ID attributes instead and changed their values, there's a possibility that we have CSS associated with the initial ID that would no longer be applied to the element.

There is no limit to the number of data attributes that can be added to an element. If you have an audio element that you want to start playing at a specific minute and second value, you could add two data attributes for the minute and second values.

In jQuery, you can read the value of a data attribute using two different methods. First is the .attr method, which allows you to specify the attribute name and get the value of the attribute. The second is the .data method. You have to be careful when using this method, since it can be used for two different data sets. If you want to obtain the value of the data-block attribute on one of the tab links, you can use the data method and pass the name of the data attribute minus the data- at the beginning of it.

$link.data('block');

This works as expected until you set a value using the data method. The setter functionality of the data method in jQuery sets a key and value pair in an internal store for data on that DOM element. This data store is not the same as the HTML data attributes, so if you set data on an element using the .data method, if you were to go back and check the HTML attribute with the same name it would be unchanged.

<a href="#" data-block="gold">Gold Sponsors</a>

var $a = $('a[data-block=gold]');

console.log($a.attr('data-block')); // gold
console.log($a.data('block')); // gold

$a.data('block', 'silver');

console.log($a.attr('data-block')); // gold
console.log($a.data('block')); // silver

In short, if you want to get or set the value of an HTML data attribute, use the .attr method. As a setter method, attr will change the HTML markup. If you want to set and retrieve custom data on an element after the page has been rendered, use the .data method. As a setter method, data will store the value on the node that can be retrieved with the data method as a getter, but it will not update the HTML markup.

As a practice problem, try making the tabbed navigation outlined previously. Create CSS to hide each article after the first using the adjacent sibling selector (article + article). Add a click event to the anchors that will locate the appropriate article, hide all others and make the located one visible. Do this using data attributes to make sure proper functionality is maintained if the elements are shuffled. Your code should look something like this:

$('a').on('click', function(e) {
  e.preventDefault();

  $('article').hide().filter('[data-block=' + $(this).attr('data-block') + ']').show();
});

If you want to work with data attributes using native DOM API's, you can. However, older versions of Internet Explorer don't behave according to the specifications when it comes to data attributes and the DOM. Still, it's good to know how jQuery works its magic.

We'll start with an element that has both an ID and a data attribute. We can then find the element using getElementById and get at its data attributes.

Copy Code
<div id="gold" data-block="gold">
  <h1>Gold Sponsors</h1>
</div>
We can store a reference to the div's DOM element using document.getElementById.

Copy Code
var gold = document.getElementById('gold');
From here, the DOM element will have a property called dataset that is a specialized object of key-value pairs. The keys, or property names, are the data attribute names. In this case, we'd have a single property name of "block". The value would be the value of the attribute, in this case "gold". We can view this object of data attributes by calling console.table again, passing in the gold DOM element's dataset property.

Copy Code
console.table(gold.dataset);

Setting the dataset properties also changes the data attributes on the corresponding HTML element, much like jQuery's .attr function.

Copy Code
gold.dataset.block = 'silver';
If we inspect our div in the browser, we can see that the attribute value has changed from gold to silver. We can also add and remove data attributes with standard object syntax.

Copy Code
gold.dataset.sponsor = 'Newman\'s Own';
delete gold.dataset.block;
One important note on setting and getting the data attributes this way is that when converting HTML attributes to DOM properties, a data attribute that contains hyphens in its name is changed to remove the hyphens and change the first letter after each hyphen to uppercase. Given this data attribute:

Copy Code
<div data-date-of-birth="28-02-1981"></div>
The DOM dataset property would be converted to:

Copy Code
div.dataset.dateOfBirth;
This property formatting is what is known as camel case. Since working with hyphens in object properties is more restrictive and requires using bracket notation, you'll most often see multi-word properties and variables either converted to camelCase or snake_case.

Copy Code
var myObject = {
  date_of_birth: '28-02-1981'
};

```
Assignment: Arithmetic Calculator
Assignment: Grocery List
Project: Guess a Word, Part 1: Core Functions
Project: Guess a Word, Part 2: Event Handling and Game Play
Project: Photo Gallery - Introduction and Server Setup
Project: Photo Gallery, Part 1 - Fetch Data and Render on Page Load
Project: Photo Gallery, Part 2 - Slide Show
Project: Photo Gallery, Part 3 - Like, Favorite and Comment